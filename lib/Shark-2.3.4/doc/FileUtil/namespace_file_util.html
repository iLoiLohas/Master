<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FileUtil: FileUtil Namespace Reference</title>
<script type="text/javaScript" src="search/search.js"></script>
<link href="../css/main.css" rel="stylesheet" type="text/css"/>
</head>
<body id="type-b">

<div id="wrap">
<div id="header">
<div id="site-name">Shark Machine Learning Library</div>
<div id="poweredby">
<img style="width: 95%;" src="../images/SharkLogo.png"/>
</div>		
  
<ul id="nav">
  <li class="first"><a href="../index.html">About Shark</a></li>
  <li><a href="#">Sourceforge</a>
  
  <ul>
    <li class="first"><a href="http://shark-project.sourceforge.net">Project Summary</a></li>
    <li><a href="http://sourceforge.net/projects/shark-project/files/">Downloads</a></li>
    <li><a href="http://sourceforge.net/projects/shark-project/develop">Subversion Repository</a></li>
  </ul>
  
</li>
<li class="first"><a href="../GettingStarted.html">Getting Started</a>
<li class="first"><a href="../Tutorials.html">Tutorials</a>
<li class="first"><a href="../FAQ.html">FAQ</a>

<li class="first"><a href="#">Main Modules</a>
<ul>
  <li class="first"><a href="../ReClaM/index.html">ReClaM</a>
  <li class="first"><a href="../EALib/index.html">EALib</a>
  <li class="first"><a href="../MOO-EALib/index.html">MOO-EALib</a>
  <li class="first"><a href="../Fuzzy/index.html">Fuzzy</a>
</ul>
</li>
<li class="first"><a href="#">Tools</a>
<ul>
  <li class="first"><a href="../Mixture/index.html">Mixture</a>
  <li><a href="../Array/index.html">Array</a>
  <li><a href="../Rng/index.html">Rng</a>
  <li><a href="../LinAlg/index.html">LinAlg</a>
  <li class="last"><a href="../FileUtil/index.html">FileUtil</a>		    
</ul>
</li>
</ul>
</div>

<!--<div id="header">
<div id="site-name">Shark Machine Learning Library</div>
  <ul id="nav">
    <li><a href="../index.html"><span>Shark&nbsp;Main&nbsp;Page</span></a></li>
    <li><a href="../Array/index.html"><span>Array</span></a></li>
    <li><a href="../Rng/index.html"><span>Rng</span></a></li>
    <li><a href="../LinAlg/index.html"><span>LinAlg</span></a></li>
    <li><a href="../FileUtil/index.html"><span>FileUtil</span></a></li>
    <li><a href="../EALib/index.html"><span>EALib</span></a></li>
    <li><a href="../MOO-EALib/index.html"><span>MOO-EALib</span></a></li>
    <li class="active"><a href="../ReClaM/index.html"><span>ReClaM</span></a></li>
    <li><a href="../Fuzzy/index.html"><span>Fuzzy</span></a></li>
    <li><a href="../Mixture/index.html"><span>Mixture</span></a></li>
    <li><a href="../tutorials/index.html"><span>Tutorials</span></a></li>
    <li><a href="../faq/index.html"><span>FAQ</span></a></li>
  </ul>
 </div> -->
<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>FileUtil Namespace Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc">iotype</a> { <a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dca380ad9dc7f58f44fc2a4c1599ea00fa1">SetDefault</a>, 
<a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dcadbd8be02aa3d5b1e3b23dc5850874d86">ScanFrom</a>, 
<a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dca4bade5acaa6add0bda5ae92d7f8d52fc">PrintTo</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Used for the functions "io" and "io_strict" to define the kind of action, that should be performed. </p>
 <a href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#aab9be1d7a4f1eecda7afa88b1ca3ad7e">special_character</a> (std::istream &amp;is, char *ch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks, whether the given character "ch" introduces a newline or tabulator.  <a href="#aab9be1d7a4f1eecda7afa88b1ca3ad7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#ac9009f9b742db4033d15e058be1e8e21">skipLine</a> (std::istream &amp;is, char *ch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips one line while reading from the input stream "is".  <a href="#ac9009f9b742db4033d15e058be1e8e21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#ae14167c7a67527cff8cbee84f5dc48d0">filesize</a> (std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in input stream "is".  <a href="#ae14167c7a67527cff8cbee84f5dc48d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a09210589f380caae4be0a74f56841223">filesize</a> (std::ostream &amp;os)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in output stream "os".  <a href="#a09210589f380caae4be0a74f56841223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a89c9915e4f27791d7b89f69e1ada5dbb">filesize</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in file "name".  <a href="#a89c9915e4f27791d7b89f69e1ada5dbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#aca522e677d94872f1e29c0654625b57d">readfile</a> (std::istream &amp;is, std::string &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The whole content of input stream "is" is stored in "buf".  <a href="#aca522e677d94872f1e29c0654625b57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a8c2f94b6ff7b02382ef534c5f27bcba8">readfile</a> (const std::string &amp;name, std::string &amp;buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The whole content of file "name" is stored in "buf".  <a href="#a8c2f94b6ff7b02382ef534c5f27bcba8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a077dd4a8a1ec9ea5869fe8ff6f5d28cb">skipuntil</a> (std::istream &amp;is, const std::string &amp;token)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from input stream "is" until "token" is found.  <a href="#a077dd4a8a1ec9ea5869fe8ff6f5d28cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a2f1666853e256e5449a294f418ff73e7">gettoken</a> (std::istream &amp;is, std::string &amp;token, const std::string &amp;delim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first token from input stream "is".  <a href="#a2f1666853e256e5449a294f418ff73e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a536fd026d5f4d6f73938a4045f415257">scanFrom</a> (std::istream &amp;is, const std::string &amp;token, std::string &amp;t, bool rew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the single value of a token from input stream "is".  <a href="#a536fd026d5f4d6f73938a4045f415257"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a6446d8b6f3676f0b4069664cd9f2b06b">scanFrom</a> (std::istream &amp;is, const std::string &amp;token, std::vector&lt; std::string &gt; &amp;t, bool rew)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one or several values of a token from input stream "is".  <a href="#a6446d8b6f3676f0b4069664cd9f2b06b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#aadd196188f517a82f0531de4b10f455c">printTo</a> (std::ostream &amp;os, const std::string &amp;token, const std::string &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a token and its single value "t" to output stream "os".  <a href="#aadd196188f517a82f0531de4b10f455c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a24cecfb8f665eeb184905e7c17720b06">printTo</a> (std::ostream &amp;os, const std::string &amp;token, const std::vector&lt; std::string &gt; &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a token and its value(s) "t" to output stream "os".  <a href="#a24cecfb8f665eeb184905e7c17720b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#aeabcc2110b9133a9c97479c4b017b842">rewind</a> (std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The get pointer is set to the beginning of stream "is".  <a href="#aeabcc2110b9133a9c97479c4b017b842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a9ba0b3a34f161edd5d2ec8f1f30539e0">rewind</a> (std::ostream &amp;os)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The put pointer is set to the beginning of stream "os".  <a href="#a9ba0b3a34f161edd5d2ec8f1f30539e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a263de3f59bca483f27cbdd0dc6826b27">scanFrom</a> (std::istream &amp;is, const std::string &amp;token, T &amp;t, bool rew=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the single value of a token from input stream "is". Very simple version.  <a href="#a263de3f59bca483f27cbdd0dc6826b27"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a17e5405f77daae31c1200d3d91be94e1">printTo</a> (std::ostream &amp;os, const std::string &amp;token, const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a token and its single value "t" to output stream "os". Very simple version.  <a href="#a17e5405f77daae31c1200d3d91be94e1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#ae57ef1cf3509d85b0128ccdacbd87eab">io</a> (std::istream &amp;is, std::ostream &amp;os, const std::string &amp;token, T &amp;val, const T &amp;defval, <a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc">iotype</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An easy to use interface to perform the three actions needed for a token.  <a href="#ae57ef1cf3509d85b0128ccdacbd87eab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#ab3e413249c38d9909cbcd5b9e0c426a7">io_strict</a> (std::istream &amp;is, std::ostream &amp;os, const std::string &amp;token, T &amp;val, const T &amp;defval, <a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc">iotype</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An easy to use interface to perform the three actions needed for a token. A very strict version, used for a special format.  <a href="#ab3e413249c38d9909cbcd5b9e0c426a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a7ebcbf2e5bc2f41439c83879988e68ac">scanLine_strict</a> (std::istream &amp;is, const std::string &amp;token, T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the single value of a token from input stream "is". A very strict version, used for a special format.  <a href="#a7ebcbf2e5bc2f41439c83879988e68ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a778eee069294346c27e5cbe0de0bb47f">scanFrom_strict</a> (std::istream &amp;is, const std::string &amp;token, T &amp;t, bool rew=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the single value of a token from input stream "is". A very strict version, used for a special format. This function is used to offer the same parameter format than #scanFrom( std::istream&amp; is, const std::string&amp; token, T&amp; t, bool rew = false ).  <a href="#a778eee069294346c27e5cbe0de0bb47f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_file_util.html#a9e8858da9efd1bd243e824e8a6dfc6c1">printTo_strict</a> (std::ostream &amp;os, const std::string &amp;token, const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a token and its single value "t" to output stream "os". A very strict version, used for a special format.  <a href="#a9e8858da9efd1bd243e824e8a6dfc6c1"></a><br/></td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="acbded1971f8560a840e192b9ffd9a8dc"></a><!-- doxytag: member="FileUtil::iotype" ref="acbded1971f8560a840e192b9ffd9a8dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc">FileUtil::iotype</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for the functions "io" and "io_strict" to define the kind of action, that should be performed. </p>
<ul>
<li>
<em>SetDefault</em> - The given token value will be initialized by the given default value. </li>
<li>
<em>ScanFrom</em> - The value for the given token will be read from the given input stream </li>
<li>
<em>PrintTo</em> - The given token and its value are written to the given output stream </li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acbded1971f8560a840e192b9ffd9a8dca380ad9dc7f58f44fc2a4c1599ea00fa1"></a><!-- doxytag: member="SetDefault" ref="acbded1971f8560a840e192b9ffd9a8dca380ad9dc7f58f44fc2a4c1599ea00fa1" args="" -->SetDefault</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acbded1971f8560a840e192b9ffd9a8dcadbd8be02aa3d5b1e3b23dc5850874d86"></a><!-- doxytag: member="ScanFrom" ref="acbded1971f8560a840e192b9ffd9a8dcadbd8be02aa3d5b1e3b23dc5850874d86" args="" -->ScanFrom</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acbded1971f8560a840e192b9ffd9a8dca4bade5acaa6add0bda5ae92d7f8d52fc"></a><!-- doxytag: member="PrintTo" ref="acbded1971f8560a840e192b9ffd9a8dca4bade5acaa6add0bda5ae92d7f8d52fc" args="" -->PrintTo</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00297">297</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae14167c7a67527cff8cbee84f5dc48d0"></a><!-- doxytag: member="FileUtil::filesize" ref="ae14167c7a67527cff8cbee84f5dc48d0" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long FileUtil::filesize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of characters in input stream "is". </p>
<p>Given the input stream "is", the number of characters in this file is returned. The position of the get pointer is not finally changed by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream to count the characters in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters in the stream.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00179">179</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8cpp_source.html#l00252">filesize()</a>.</p>

</div>
</div>
<a class="anchor" id="a09210589f380caae4be0a74f56841223"></a><!-- doxytag: member="FileUtil::filesize" ref="a09210589f380caae4be0a74f56841223" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long FileUtil::filesize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of characters in output stream "os". </p>
<p>Given the output stream "os", the number of characters in this file is returned. The position of the put pointer is not finally changed by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to count the characters in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters in the stream.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00217">217</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89c9915e4f27791d7b89f69e1ada5dbb"></a><!-- doxytag: member="FileUtil::filesize" ref="a89c9915e4f27791d7b89f69e1ada5dbb" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long FileUtil::filesize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of characters in file "name". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters in the file or zero, when the file can't be opened.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00252">252</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>References <a class="el" href="_file_util_8cpp_source.html#l00179">filesize()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f1666853e256e5449a294f418ff73e7"></a><!-- doxytag: member="FileUtil::gettoken" ref="a2f1666853e256e5449a294f418ff73e7" args="(std::istream &amp;is, std::string &amp;token, const std::string &amp;delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char FileUtil::gettoken </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the first token from input stream "is". </p>
<p>Tokens are separated by delimiters. The string <em>delim</em> is used to enumerate all characters used as delimiters. The delimiters are used then to identify the first token. Any leading delimiters are ignored. An iterative usage of this function will read token after token, because the get pointer is set to the first delimiter after the next token.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream the token is read from. </td></tr>
    <tr><td class="paramname">token</td><td>Used to store the token that is read from <em>is</em>. </td></tr>
    <tr><td class="paramname">delim</td><td>String of characters that are used as delimiters. By default the whitespace character, the tabulator, the carriage return, the newline character, the vertical tabulator and the form feed character are used as delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first delimiter after the token.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>2002-01-03, ra: The first character of a token was ignored, when no whitespace followed the leading delimiters - fixed.</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00432">432</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae57ef1cf3509d85b0128ccdacbd87eab"></a><!-- doxytag: member="FileUtil::io" ref="ae57ef1cf3509d85b0128ccdacbd87eab" args="(std::istream &amp;is, std::ostream &amp;os, const std::string &amp;token, T &amp;val, const T &amp;defval, iotype type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FileUtil::io </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>defval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iotype&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An easy to use interface to perform the three actions needed for a token. </p>
<p>You can use this function to specify all information for a token once and then initialize it with a default value or read a new value for it from an input stream or write the token and its already given value to an output stream. This can be done by using different values for the action indicator <em>type</em>. <br/>
 Use this function with caution, if you are using it for reading the value of a token from input stream <em>is</em>, because a string read from the input stream is identified as the searched token when this searched token is a prefix of this string, e.g. if you are searching for a token "a" and one line of the input stream begins with "ab". <br/>
 This is especially dangerous when using short token names. <br/>
 If you are using token names of this kind or are not sure, that the scenario above won't occur, use function <a class="el" href="namespace_file_util.html#ab3e413249c38d9909cbcd5b9e0c426a7" title="An easy to use interface to perform the three actions needed for a token. A very strict version...">io_strict</a> instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream used, when reading a token value. </td></tr>
    <tr><td class="paramname">os</td><td>The output stream used, when writing the token and its value. </td></tr>
    <tr><td class="paramname">token</td><td>The token used for initializing/reading/writing. </td></tr>
    <tr><td class="paramname">val</td><td>Used to store the current value of the token. </td></tr>
    <tr><td class="paramname">defval</td><td>The default value that is used for initialization. </td></tr>
    <tr><td class="paramname">type</td><td>The action indicator. See <a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc" title="Used for the functions &quot;io&quot; and &quot;io_strict&quot; to define the kind of action...">iotype</a> definition for the different values and their meanings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00345">345</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>References <a class="el" href="_file_util_8cpp_source.html#l00795">printTo()</a>, <a class="el" href="_file_util_8h_source.html#l00299">PrintTo</a>, <a class="el" href="_file_util_8cpp_source.html#l00599">scanFrom()</a>, <a class="el" href="_file_util_8h_source.html#l00299">ScanFrom</a>, and <a class="el" href="_file_util_8h_source.html#l00299">SetDefault</a>.</p>

</div>
</div>
<a class="anchor" id="ab3e413249c38d9909cbcd5b9e0c426a7"></a><!-- doxytag: member="FileUtil::io_strict" ref="ab3e413249c38d9909cbcd5b9e0c426a7" args="(std::istream &amp;is, std::ostream &amp;os, const std::string &amp;token, T &amp;val, const T &amp;defval, iotype type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FileUtil::io_strict </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>defval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iotype&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An easy to use interface to perform the three actions needed for a token. A very strict version, used for a special format. </p>
<p>You can use this function to specify all information for a token once and then initialize it with a default value or read a new value for it from an input stream or write the token and its already given value to an output stream. This can be done by using different values for the action indicator <em>type</em>. <br/>
 This function here is used to prevent a disadvantage of <a class="el" href="namespace_file_util.html#ae57ef1cf3509d85b0128ccdacbd87eab" title="An easy to use interface to perform the three actions needed for a token.">io</a>, when reading a token value from an input stream. There a string read from the input stream is identified as the searched token when this searched token is a prefix of this string, e.g. if you are searching for a token "a" and one line of the input stream begins with "ab". <br/>
 This is especially dangerous when using short token names.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream used, when reading a token value. </td></tr>
    <tr><td class="paramname">os</td><td>The output stream used, when writing the token and its value. </td></tr>
    <tr><td class="paramname">token</td><td>The token used for initializing/reading/writing. </td></tr>
    <tr><td class="paramname">val</td><td>Used to store the current value of the token. </td></tr>
    <tr><td class="paramname">defval</td><td>The default value that is used for initialization. </td></tr>
    <tr><td class="paramname">type</td><td>The action indicator. See <a class="el" href="namespace_file_util.html#acbded1971f8560a840e192b9ffd9a8dc" title="Used for the functions &quot;io&quot; and &quot;io_strict&quot; to define the kind of action...">iotype</a> definition for the different values and their meanings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>R. Alberts </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1999</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>2002-01-03, ra <br/>
 Renamed to from "io2" to "io_strict" for unification, new function "printTo_strict" added.</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_file_util_class_8cpp-example.html#a5">FileUtilClass.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00406">406</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>References <a class="el" href="_file_util_8h_source.html#l00299">PrintTo</a>, <a class="el" href="_file_util_8h_source.html#l00624">printTo_strict()</a>, <a class="el" href="_file_util_8h_source.html#l00299">ScanFrom</a>, <a class="el" href="_file_util_8h_source.html#l00571">scanFrom_strict()</a>, and <a class="el" href="_file_util_8h_source.html#l00299">SetDefault</a>.</p>

</div>
</div>
<a class="anchor" id="a17e5405f77daae31c1200d3d91be94e1"></a><!-- doxytag: member="FileUtil::printTo" ref="a17e5405f77daae31c1200d3d91be94e1" args="(std::ostream &amp;os, const std::string &amp;token, const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::printTo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a token and its single value "t" to output stream "os". Very simple version. </p>
<p>If you want to create files that can be used to initialize variables, you can use this function. The value <em>t</em> for a variable with name <em>token</em> will be written to output stream <em>os</em>. The data is written in a formatted manner, i.e. the width of a token-value line is always 40 characters and the token and its value are separated by "_" characters. <br/>
 Please notice that the formatted output is ignored by older compilers. <br/>
 In contrast to the other "printTo" functions the token value can not include escape sequences. The disadvantage of the other "printTo" functions is, that the token values must always be stored in strings, independend from their real type. Here you can use a copy of the original value without casting it to string before. <br/>
 This is the opposite function of #scanFrom(std::istream&amp; is, const std::string&amp; token, T&amp; t, bool rew = false ).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The input stream the token and its value are written to. </td></tr>
    <tr><td class="paramname">token</td><td>The token that will be written. </td></tr>
    <tr><td class="paramname">t</td><td>The token value that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while writing to <em>os</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00238">238</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>References <a class="el" href="_file_util_8cpp_source.html#l00795">printTo()</a>.</p>

</div>
</div>
<a class="anchor" id="aadd196188f517a82f0531de4b10f455c"></a><!-- doxytag: member="FileUtil::printTo" ref="aadd196188f517a82f0531de4b10f455c" args="(std::ostream &amp;os, const std::string &amp;token, const std::string &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::printTo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a token and its single value "t" to output stream "os". </p>
<p>If you want to create files that can be used to initialize variables, you can use this function. The value <em>t</em> for a variable with name <em>token</em> will be written to output stream <em>os</em>. <em>t</em> can include tabulator characters, carriage returns, newlines, vertical tabulators, alert bells, form feeds, backspaces and escape characters. <br/>
 This is the opposite function of <a class="el" href="namespace_file_util.html#a536fd026d5f4d6f73938a4045f415257" title="Reads the single value of a token from input stream &quot;is&quot;.">scanFrom(std::istream&amp; is, const std::string&amp; token, std::string&amp; t, bool rew)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The input stream the token and its value are written to. </td></tr>
    <tr><td class="paramname">token</td><td>The token that will be written. </td></tr>
    <tr><td class="paramname">t</td><td>The token value that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while writing to <em>os</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00795">795</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00345">io()</a>, and <a class="el" href="_file_util_8h_source.html#l00238">printTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a24cecfb8f665eeb184905e7c17720b06"></a><!-- doxytag: member="FileUtil::printTo" ref="a24cecfb8f665eeb184905e7c17720b06" args="(std::ostream &amp;os, const std::string &amp;token, const std::vector&lt; std::string &gt; &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::printTo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a token and its value(s) "t" to output stream "os". </p>
<p>If you want to create files that can be used to initialize variables, you can use this function. The value(s) <em>t</em> for a variable with name <em>token</em> will be written to output stream <em>os</em>. Each single value in <em>t</em> can include tabulator characters, carriage returns, newlines, vertical tabulators, alert bells, form feeds, backspaces and escape characters. <br/>
 This is the opposite function of <a class="el" href="namespace_file_util.html#a6446d8b6f3676f0b4069664cd9f2b06b" title="Reads one or several values of a token from input stream &quot;is&quot;.">scanFrom(std::istream&amp; is, const std::string&amp; token, std::vector&lt; std::string &gt;&amp; t, bool rew)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The input stream the token and its value(s) are written to. </td></tr>
    <tr><td class="paramname">token</td><td>The token that will be written. </td></tr>
    <tr><td class="paramname">t</td><td>The value(s) of the token that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while writing to <em>os</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00835">835</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e8858da9efd1bd243e824e8a6dfc6c1"></a><!-- doxytag: member="FileUtil::printTo_strict" ref="a9e8858da9efd1bd243e824e8a6dfc6c1" args="(std::ostream &amp;os, const std::string &amp;token, const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::printTo_strict </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a token and its single value "t" to output stream "os". A very strict version, used for a special format. </p>
<p>If you want to create files that can be used to initialize variables, you can use this function. The value <em>t</em> for a variable with name <em>token</em> will be written to output stream <em>os</em>. <br/>
 Before writing the token name and its value, the token name is checked for the right format: <br/>
 The first character of a token name must be a letter or an underscore, all further characters must be a letter, a digit or an underscore. If this format is not satisfied, the function will exit with an error message. <br/>
 This function is the opposite function of <a class="el" href="namespace_file_util.html#a778eee069294346c27e5cbe0de0bb47f" title="Reads the single value of a token from input stream &quot;is&quot;. A very strict version...">scanFrom_strict(std::istream&amp;, const std::string&amp;, T&amp;, bool)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The input stream the token and its value are written to. </td></tr>
    <tr><td class="paramname">token</td><td>The token that will be written. </td></tr>
    <tr><td class="paramname">t</td><td>The token value that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while writing to <em>os</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>R. Alberts </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2002-01-03</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00624">624</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00406">io_strict()</a>.</p>

</div>
</div>
<a class="anchor" id="aca522e677d94872f1e29c0654625b57d"></a><!-- doxytag: member="FileUtil::readfile" ref="aca522e677d94872f1e29c0654625b57d" args="(std::istream &amp;is, std::string &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long FileUtil::readfile </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The whole content of input stream "is" is stored in "buf". </p>
<p>All characters in input stream <em>is</em> are read and stored in buffer <em>buf</em>. The current position of the get pointer is not finally changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input stream from which the content is read. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer where the content of <em>is</em> is stored in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters read from <em>is</em>.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00285">285</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8cpp_source.html#l00332">readfile()</a>, and <a class="el" href="_params_8cpp_source.html#l00208">Params::scanFrom()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c2f94b6ff7b02382ef534c5f27bcba8"></a><!-- doxytag: member="FileUtil::readfile" ref="a8c2f94b6ff7b02382ef534c5f27bcba8" args="(const std::string &amp;name, std::string &amp;buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long FileUtil::readfile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The whole content of file "name" is stored in "buf". </p>
<p>All characters in the file named <em>name</em> are read and stored in buffer <em>buf</em>. The current position of the get pointer is not finally changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of file from which the content is read. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer where the content of file <em>name</em> is stored in. If <em>name</em> doesn't exist, the buffer is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters read from <em>name</em>, or "0", when the file doesn't exist.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00332">332</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>References <a class="el" href="_file_util_8cpp_source.html#l00285">readfile()</a>.</p>

</div>
</div>
<a class="anchor" id="aeabcc2110b9133a9c97479c4b017b842"></a><!-- doxytag: member="FileUtil::rewind" ref="aeabcc2110b9133a9c97479c4b017b842" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FileUtil::rewind </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The get pointer is set to the beginning of stream "is". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00082">82</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8cpp_source.html#l00599">scanFrom()</a>, and <a class="el" href="_file_util_8h_source.html#l00571">scanFrom_strict()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ba0b3a34f161edd5d2ec8f1f30539e0"></a><!-- doxytag: member="FileUtil::rewind" ref="a9ba0b3a34f161edd5d2ec8f1f30539e0" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FileUtil::rewind </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The put pointer is set to the beginning of stream "os". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00104">104</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

</div>
</div>
<a class="anchor" id="a536fd026d5f4d6f73938a4045f415257"></a><!-- doxytag: member="FileUtil::scanFrom" ref="a536fd026d5f4d6f73938a4045f415257" args="(std::istream &amp;is, const std::string &amp;token, std::string &amp;t, bool rew)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::scanFrom </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the single value of a token from input stream "is". </p>
<p>This function is used for files that contain initialization values for variables. The name of the variable is used as search token and the value following these token is stored and can be used as new value for the variable with name <em>token</em>. To identify the token value (and to differentiate it from the token itself) it can be enclosed in quotation marks or inverted commas. The value can include tabulator characters, carriage returns, newlines, vertical tabulators, alert bells, form feeds, backspaces and escape characters, but no whitespaces. <br/>
 This is the opposite function of <a class="el" href="namespace_file_util.html#aadd196188f517a82f0531de4b10f455c" title="Writes a token and its single value &quot;t&quot; to output stream &quot;os&quot;.">printTo(std::ostream&amp; os, const std::string&amp; token, const std::string&amp; t)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream the token value is read from. </td></tr>
    <tr><td class="paramname">token</td><td>The token for which the value is read. </td></tr>
    <tr><td class="paramname">t</td><td>Used to store the token value found. Note, that the value is stored as string, independend from its original type. </td></tr>
    <tr><td class="paramname">rew</td><td>If set to "true", the search will start at the beginning of the stream; if set to "false" the search will start at the current position of the get pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while reading from <em>is</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00599">599</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>References <a class="el" href="_file_util_8h_source.html#l00082">rewind()</a>, and <a class="el" href="_file_util_8cpp_source.html#l00371">skipuntil()</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00345">io()</a>, and <a class="el" href="_file_util_8h_source.html#l00181">scanFrom()</a>.</p>

</div>
</div>
<a class="anchor" id="a263de3f59bca483f27cbdd0dc6826b27"></a><!-- doxytag: member="FileUtil::scanFrom" ref="a263de3f59bca483f27cbdd0dc6826b27" args="(std::istream &amp;is, const std::string &amp;token, T &amp;t, bool rew=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::scanFrom </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rew</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the single value of a token from input stream "is". Very simple version. </p>
<p>This is the opposite function of <a class="el" href="namespace_file_util.html#a17e5405f77daae31c1200d3d91be94e1" title="Writes a token and its single value &quot;t&quot; to output stream &quot;os&quot;. Very simple version.">printTo(std::ostream&amp; os, const std::string&amp; token, const T&amp; t)</a>. and is used for files that contain initialization values for variables. The name of the variable is used as search token and the value following these token is stored and can be used as new value for the variable with name <em>token</em>. <br/>
 In contrast to the other "scanFrom" functions you can not enclose the token value in quotation marks or inverted commas for a better identification, nor can the token value include escape sequences. The disadvantage of the other "scanFrom" functions is, that the token values are always stored in strings, independend from their real type. Here you can use a buffer <em>t</em> with the right type. <br/>
 Use this function with caution, because a string read from the input stream is identified as the searched token when this searched token is a prefix of this string, e.g. if you are searching for a token "a" and one line of the input stream begins with "ab". <br/>
 This is especially dangerous when using short token names. <br/>
 If you are using token names of this kind or are not sure, that the scenario above won't occur, use function <a class="el" href="namespace_file_util.html#a778eee069294346c27e5cbe0de0bb47f" title="Reads the single value of a token from input stream &quot;is&quot;. A very strict version...">scanFrom_strict</a>(std::istream&amp; is, const std::string&amp; token, T&amp; t, bool rew = false) instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream the token value is read from. </td></tr>
    <tr><td class="paramname">token</td><td>The token for which the value is read. </td></tr>
    <tr><td class="paramname">t</td><td>Used to store the token value found. </td></tr>
    <tr><td class="paramname">rew</td><td>If set to "true", the search will start at the beginning of the stream; if set to "false" (default value) the search will start at the current position of the get pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while reading from <em>is</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00181">181</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>References <a class="el" href="_file_util_8h_source.html#l00082">rewind()</a>, <a class="el" href="_file_util_8cpp_source.html#l00599">scanFrom()</a>, and <a class="el" href="_file_util_8cpp_source.html#l00371">skipuntil()</a>.</p>

</div>
</div>
<a class="anchor" id="a6446d8b6f3676f0b4069664cd9f2b06b"></a><!-- doxytag: member="FileUtil::scanFrom" ref="a6446d8b6f3676f0b4069664cd9f2b06b" args="(std::istream &amp;is, const std::string &amp;token, std::vector&lt; std::string &gt; &amp;t, bool rew)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::scanFrom </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads one or several values of a token from input stream "is". </p>
<p>Reads one or several values of a token.</p>
<p>This function is used for files that contain initialization values for variables. The name of the variable is used as search token and the value(s) following these token are stored and can be used as new value(s) for the variable with name <em>token</em>. To identify the token value(s) (and to differentiate it/them from the token itself), each single value can be enclosed in quotation marks or inverted commas. If more than one value is used, the list of all values must be enclosed in parentheses. Values can include tabulator characters, carriage returns, newlines, vertical tabulators, alert bells, form feeds, backspaces and escape characters, but no whitespaces. <br/>
 This is the opposite function of <a class="el" href="namespace_file_util.html#a24cecfb8f665eeb184905e7c17720b06" title="Writes a token and its value(s) &quot;t&quot; to output stream &quot;os&quot;.">printTo(std::ostream&amp; os, const std::string&amp; token, const std::vector&lt; std::string &gt;&amp; t)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream the token value(s) is/are read from. </td></tr>
    <tr><td class="paramname">token</td><td>The token for which the value(s) is/are read. </td></tr>
    <tr><td class="paramname">t</td><td>All token values found are stored in this vector. Note, that the value(s) is/are stored as string(s), independend from its/their original type(s). </td></tr>
    <tr><td class="paramname">rew</td><td>If set to "true", the search will start at the beginning of the stream; if set to "false" the search will start at the current position of the get pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while reading from <em>is</em>, "false" otherwise.</dd></dl>
<dl class="user"><dt><b>Example</b></dt><dd></dd></dl>
<p><img class="formulaInl" alt="$ \begin{array}{ll} var1 &amp; (&quot;0.25&quot;\ &quot;0.32&quot;\ &quot;0.99&quot;)\\ var2 &amp; &quot;testfile.dat&quot;\\ var3 &amp; 10\\ \end{array} $" src="form_0.png"/></p>
<p>If you call the function three times for a file with the content shown above it first will read the values <img class="formulaInl" alt="$0.25$" src="form_1.png"/>, <img class="formulaInl" alt="$0.32$" src="form_2.png"/> and <img class="formulaInl" alt="$0.99$" src="form_3.png"/> for a double variable with the name <img class="formulaInl" alt="$var1$" src="form_4.png"/>, then the single value <img class="formulaInl" alt="$testfile.dat$" src="form_5.png"/> for a variable named <img class="formulaInl" alt="$var2$" src="form_6.png"/> and finally the value <img class="formulaInl" alt="$10$" src="form_7.png"/> (note, that this value is not enclosed in quotation marks or inverted commas) for an integer variable named <img class="formulaInl" alt="$var3$" src="form_8.png"/>.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00667">667</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>References <a class="el" href="_file_util_8h_source.html#l00082">rewind()</a>, and <a class="el" href="_file_util_8cpp_source.html#l00371">skipuntil()</a>.</p>

</div>
</div>
<a class="anchor" id="a778eee069294346c27e5cbe0de0bb47f"></a><!-- doxytag: member="FileUtil::scanFrom_strict" ref="a778eee069294346c27e5cbe0de0bb47f" args="(std::istream &amp;is, const std::string &amp;token, T &amp;t, bool rew=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::scanFrom_strict </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rew</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the single value of a token from input stream "is". A very strict version, used for a special format. This function is used to offer the same parameter format than #scanFrom( std::istream&amp; is, const std::string&amp; token, T&amp; t, bool rew = false ). </p>
<p>See function #scanFrom_strict(std::istream&amp; is, const std::string&amp; token, T&amp; t) for a description of the functioning. This function here is used to prevent a disadvantage of #scanFrom( std::istream&amp; is, const std::string&amp; token, T&amp; t, bool rew = false ), where a string read from the input stream is identified as the searched token when this searched token is a prefix of this string, e.g. if you are searching for a token "a" and one line of the input stream begins with "ab". <br/>
 This is especially dangerous when using short token names. <br/>
 This function here is the opposite function of <a class="el" href="namespace_file_util.html#a9e8858da9efd1bd243e824e8a6dfc6c1" title="Writes a token and its single value &quot;t&quot; to output stream &quot;os&quot;. A very strict version, used for a special format.">printTo_strict</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream the token value is read from. </td></tr>
    <tr><td class="paramname">token</td><td>The token for which the value is read. </td></tr>
    <tr><td class="paramname">t</td><td>Used to store the token value found. </td></tr>
    <tr><td class="paramname">rew</td><td>If set to "true", the search will start at the beginning of the stream; if set to "false" (default value) the search will start at the current position of the get pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if no error occured while reading from <em>is</em>, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>R. Alberts </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1999</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>Renamed from "scanFrom2" to "scanFrom_strict" for unification.</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_file_util_simple_8cpp-example.html#a0">FileUtilSimple.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00571">571</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>References <a class="el" href="_file_util_8h_source.html#l00082">rewind()</a>, and <a class="el" href="_file_util_8h_source.html#l00466">scanLine_strict()</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00406">io_strict()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ebcbf2e5bc2f41439c83879988e68ac"></a><!-- doxytag: member="FileUtil::scanLine_strict" ref="a7ebcbf2e5bc2f41439c83879988e68ac" args="(std::istream &amp;is, const std::string &amp;token, T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::scanLine_strict </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the single value of a token from input stream "is". A very strict version, used for a special format. </p>
<p>This function is used for files that contain initialization values for variables. The name of the variable is used as search token and the value following these token is stored and can be used as new value for the variable with name <em>token</em>. <br/>
 In contrast to the other "scanFrom" functions the files used for this function must have a very strict format: <br/>
 Each line contains the token name AND its corresponding value, it is not allowed to store the token name in one line and its value in the next line. Furthermore, each token name stands at the beginning of a line, no leading whitespaces or tabulators are allowed. The first character of a token name must be a letter or an underscore, all further characters must be a letter, a digit or an underscore. The token name and the token value are separated by whitespaces and/or tabulators, no other delimiters are allowed. The token name read from the stream must match the token name given exactly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream the token value is read from. </td></tr>
    <tr><td class="paramname">token</td><td>The token for which the value is read from <em>is</em>. </td></tr>
    <tr><td class="paramname">t</td><td>The value of the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", if the token and its value are found; "false", if the token or its value are not found or if an error occured while reading from <em>is</em>.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>R. Alberts </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1999</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>2002-01-03, ra: <br/>
 Renamed from "scanLine" to "scanLine_strict" for unification.</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8h_source.html#l00466">466</a> of file <a class="el" href="_file_util_8h_source.html">FileUtil.h</a>.</p>

<p>References <a class="el" href="_file_util_8cpp_source.html#l00144">skipLine()</a>, and <a class="el" href="_file_util_8cpp_source.html#l00099">special_character()</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00571">scanFrom_strict()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9009f9b742db4033d15e058be1e8e21"></a><!-- doxytag: member="FileUtil::skipLine" ref="ac9009f9b742db4033d15e058be1e8e21" args="(std::istream &amp;is, char *ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::skipLine </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skips one line while reading from the input stream "is". </p>
<p>This function reads from the given input stream <em>is</em>, starting at the current position of the get pointer and searches for the next newline character if available. When a newline exists, the whole line was read in and so the position of the get pointer set to the beginning of the next line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream from which is read. </td></tr>
    <tr><td class="paramname">ch</td><td>At the end of the function you can find the last character that was read here (a newline in normal case). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", when a newline was found, "false" when the end of file was reached before or a character couldn't be read.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>R. Alberts </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1999</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00144">144</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>References <a class="el" href="_file_util_8cpp_source.html#l00099">special_character()</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00466">scanLine_strict()</a>.</p>

</div>
</div>
<a class="anchor" id="a077dd4a8a1ec9ea5869fe8ff6f5d28cb"></a><!-- doxytag: member="FileUtil::skipuntil" ref="a077dd4a8a1ec9ea5869fe8ff6f5d28cb" args="(std::istream &amp;is, const std::string &amp;token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FileUtil::skipuntil </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads from input stream "is" until "token" is found. </p>
<p>Starting at the current position of the get pointer, it is searched for the next occurence of <em>token</em>. If the token is found, the get pointer is set to the first position after the token, otherwise the pointer is set to the end of the file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
    <tr><td class="paramname">token</td><td>A string for which is searched in <em>is</em>. If the string is empty, the function returns immediately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00371">371</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8cpp_source.html#l00599">scanFrom()</a>.</p>

</div>
</div>
<a class="anchor" id="aab9be1d7a4f1eecda7afa88b1ca3ad7e"></a><!-- doxytag: member="FileUtil::special_character" ref="aab9be1d7a4f1eecda7afa88b1ca3ad7e" args="(std::istream &amp;is, char *ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileUtil::special_character </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks, whether the given character "ch" introduces a newline or tabulator. </p>
<p>Escape sequences like the tabulator or the newline consist of two characters. The first one is the escape character "\\" that marks the beginning of an escape sequence, the second one is the type of sequence ("t" for tabulator, "n" for newline). This function takes the given character <em>ch</em>, checks, whether this character is an escape character and when this is true, reads in the next character from the given input stream <em>is</em>. If the next character is a "t" or "n", then "true" is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream from which the first character was taken and the next character can be read. </td></tr>
    <tr><td class="paramname">ch</td><td>The first character that was read from the input stream and is checked for the escape character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>"true", when <em>ch</em> introduces a newline or tabulator, "false" otherwise.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>R. Alberts </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1999</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable</dd></dl>

<p>Definition at line <a class="el" href="_file_util_8cpp_source.html#l00099">99</a> of file <a class="el" href="_file_util_8cpp_source.html">FileUtil.cpp</a>.</p>

<p>Referenced by <a class="el" href="_file_util_8h_source.html#l00466">scanLine_strict()</a>, and <a class="el" href="_file_util_8cpp_source.html#l00144">skipLine()</a>.</p>

</div>
</div>
</div>
</div>
</div>
</body></html>
