<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LinAlg: LinAlg.h File Reference</title>
<script type="text/javaScript" src="search/search.js"></script>
<link href="../css/main.css" rel="stylesheet" type="text/css"/>
</head>
<body id="type-b">

<div id="wrap">
<div id="header">
<div id="site-name">Shark Machine Learning Library</div>
<div id="poweredby">
<img style="width: 95%;" src="../images/SharkLogo.png"/>
</div>		
  
<ul id="nav">
  <li class="first"><a href="../index.html">About Shark</a></li>
  <li><a href="#">Sourceforge</a>
  
  <ul>
    <li class="first"><a href="http://shark-project.sourceforge.net">Project Summary</a></li>
    <li><a href="http://sourceforge.net/projects/shark-project/files/">Downloads</a></li>
    <li><a href="http://sourceforge.net/projects/shark-project/develop">Subversion Repository</a></li>
  </ul>
  
</li>
<li class="first"><a href="../GettingStarted.html">Getting Started</a>
<li class="first"><a href="../Tutorials.html">Tutorials</a>
<li class="first"><a href="../FAQ.html">FAQ</a>

<li class="first"><a href="#">Main Modules</a>
<ul>
  <li class="first"><a href="../ReClaM/index.html">ReClaM</a>
  <li class="first"><a href="../EALib/index.html">EALib</a>
  <li class="first"><a href="../MOO-EALib/index.html">MOO-EALib</a>
  <li class="first"><a href="../Fuzzy/index.html">Fuzzy</a>
</ul>
</li>
<li class="first"><a href="#">Tools</a>
<ul>
  <li class="first"><a href="../Mixture/index.html">Mixture</a>
  <li><a href="../Array/index.html">Array</a>
  <li><a href="../Rng/index.html">Rng</a>
  <li><a href="../LinAlg/index.html">LinAlg</a>
  <li class="last"><a href="../FileUtil/index.html">FileUtil</a>		    
</ul>
</li>
</ul>
</div>

<!--<div id="header">
<div id="site-name">Shark Machine Learning Library</div>
  <ul id="nav">
    <li><a href="../index.html"><span>Shark&nbsp;Main&nbsp;Page</span></a></li>
    <li><a href="../Array/index.html"><span>Array</span></a></li>
    <li><a href="../Rng/index.html"><span>Rng</span></a></li>
    <li><a href="../LinAlg/index.html"><span>LinAlg</span></a></li>
    <li><a href="../FileUtil/index.html"><span>FileUtil</span></a></li>
    <li><a href="../EALib/index.html"><span>EALib</span></a></li>
    <li><a href="../MOO-EALib/index.html"><span>MOO-EALib</span></a></li>
    <li class="active"><a href="../ReClaM/index.html"><span>ReClaM</span></a></li>
    <li><a href="../Fuzzy/index.html"><span>Fuzzy</span></a></li>
    <li><a href="../Mixture/index.html"><span>Mixture</span></a></li>
    <li><a href="../tutorials/index.html"><span>Tutorials</span></a></li>
    <li><a href="../faq/index.html"><span>FAQ</span></a></li>
  </ul>
 </div> -->
<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>LinAlg.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Some operations for matrices.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;Array/Array2D.h&quot;</code><br/>
</div>
<p><a href="_lin_alg_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#aa85867998d5a6b2ca11626cda4dde9d5">eigensort</a> (Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the eigenvalues in vector "dvecA" in descending order and the corresponding eigenvectors in matrix "vmatA".  <a href="#aa85867998d5a6b2ca11626cda4dde9d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#acd05caa966d2ee1bf5f85fb8d4360d4a">eigensymmJacobi</a> (Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix "amatA" using the Jacobi method.  <a href="#acd05caa966d2ee1bf5f85fb8d4360d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ab11a543dec385422cc31d628396e9c7a">eigensymmJacobi2</a> (Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix "amatA" using a modified Jacobi method.  <a href="#ab11a543dec385422cc31d628396e9c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ac7c3faaaece1bcbea6d04e1939c7d9f2">eigensymm_intermediate</a> (const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;hmatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction, however, "hmatA" contains intermediate results after application.  <a href="#ac7c3faaaece1bcbea6d04e1939c7d9f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a4740d207478277949f92864c6c36c648">eigensymm</a> (const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as frontend for <a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140" title="Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix &quot;amatA&quot; us...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA,Array&lt;double&gt; &amp;odvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "amatA" during application.  <a href="#a4740d207478277949f92864c6c36c648"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ab030e103592a6769e7848d27c0b9bdaa">eigensymm</a> (const Array&lt; double &gt; &amp;A, Array&lt; double &gt; &amp;G, Array&lt; double &gt; &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as another frontend for <a class="el" href="_lin_alg_8h.html#a4740d207478277949f92864c6c36c648" title="Used as frontend for eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmat...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "A" during application.  <a href="#ab030e103592a6769e7848d27c0b9bdaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140">eigensymm</a> (const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA, Array&lt; double &gt; &amp;odvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction.  <a href="#ac4ac4221d20c0560656c7582295a2140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a218cdfe4b0bbc068317ee65caad3cd11">eigensymm</a> (const Array&lt; double &gt; &amp;A, Array&lt; double &gt; &amp;G, Array&lt; double &gt; &amp;l, Array&lt; double &gt; &amp;od)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as frontend for <a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140" title="Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix &quot;amatA&quot; us...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA,Array&lt;double&gt; &amp;odvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "A" during application.  <a href="#a218cdfe4b0bbc068317ee65caad3cd11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a139c942be3ee988a6ac301a2252f186c">eigen</a> (Array&lt; double &gt; A, Array&lt; double &gt; &amp;vr, Array&lt; double &gt; &amp;vi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues of an arbitrary matrix "amatA" by balancing the elements of the matrix, then reducing it to an upper Hessenberg matrix and finally calculating the eigenvalues ot the reduced form.  <a href="#a139c942be3ee988a6ac301a2252f186c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ae1a498500ef614caa47ccb6a38cfadd0">CholeskyDecomposition</a> (const Array2D&lt; double &gt; &amp;M, Array2D&lt; double &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">lower triangular Cholesky decomposition  <a href="#ae1a498500ef614caa47ccb6a38cfadd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a19601b671142e21554e4709521fddb51">eigenerr</a> (const Array2D&lt; double &gt; &amp;amatA, const Array2D&lt; double &gt; &amp;vmatA, const Array&lt; double &gt; &amp;dvecA, unsigned c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the relative error of eigenvalue no. "c".  <a href="#a19601b671142e21554e4709521fddb51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#afeb67af8cfdd3d583ad3e6d3dbc4322d">sym_rank</a> (const Array2D&lt; double &gt; &amp;amatA, const Array2D&lt; double &gt; &amp;vmatA, const Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the rank of the symmetric matrix "amatA".  <a href="#afeb67af8cfdd3d583ad3e6d3dbc4322d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a44ada29d9de0ab64d3dc6cd1ca91e47f">detsymm</a> (Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the symmetric matrix "amatA".  <a href="#a44ada29d9de0ab64d3dc6cd1ca91e47f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a22e15a9ee0c067a8d392ded500a8f509">logdetsymm</a> (Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of the determinant of the symmetric matrix "amatA".  <a href="#a22e15a9ee0c067a8d392ded500a8f509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a44a6bc0eed7b59bda939e3602f6fb0bc">rankDecomp</a> (Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array2D&lt; double &gt; &amp;hmatA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rank of the symmetric matrix "amatA", its eigenvalues and eigenvectors.  <a href="#a44a6bc0eed7b59bda939e3602f6fb0bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ac1a847ab3c268fb6f5531a22656cc0c6">discrimAnalysis</a> (Array2D&lt; double &gt; &amp;betweenCovarA, Array2D&lt; double &gt; &amp;withinCovarA, Array2D&lt; double &gt; &amp;transMatA, Array&lt; double &gt; &amp;dvecA, unsigned &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given "m" classes of data, the covariances between the values within one class and the covariances between all the classes, this method calculates the transformation matrix that will project the data in a way, that maximum separation of the different classes is given.  <a href="#ac1a847ab3c268fb6f5531a22656cc0c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a4c2904a5d984482d5e4f49f8854f7520">linearRegress</a> (Array2D&lt; double &gt; &amp;cxxMatA, Array2D&lt; double &gt; &amp;cxyMatA, Array&lt; double &gt; &amp;mxVecA, Array&lt; double &gt; &amp;myVecA, Array2D&lt; double &gt; &amp;amatA, Array&lt; double &gt; &amp;bvecA, Array&lt; double &gt; &amp;dvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the correlations of the n-dimensional data vector "x" and the m-dimensional data vector "y" and also given their mean values, this function summarizes the data by finding a linear mapping that will approximate the data.  <a href="#a4c2904a5d984482d5e4f49f8854f7520"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a68df2fc67b9bf10bb9ef079230fe23d3">svdrank</a> (const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;umatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;wvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the numerical rank of a rectangular matrix "amatA", when a singular value decomposition for "amatA" has taken place before.  <a href="#a68df2fc67b9bf10bb9ef079230fe23d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#aa79960c3f97b3ea7dd322072e4089119">svd</a> (const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;umatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;wvecA, unsigned maxIterations=200, bool ignoreThreshold=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the singular value decomposition of a rectangular matrix "amatA".  <a href="#aa79960c3f97b3ea7dd322072e4089119"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a12f83de2c8c11c875eafc3d4fef3e492">svdsort</a> (Array2D&lt; double &gt; &amp;umatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;wvecA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the singular values in vector "wvecA" by descending order.  <a href="#a12f83de2c8c11c875eafc3d4fef3e492"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#aaa164073a51840262b1be68a17f91a73">transpose</a> (const Array&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a9b1705b71b00806be6951614c700abf0">diagonal</a> (const Array&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ab6af2de50659417cf1e06d6ccb28a76c">trace</a> (const Array&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Array&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#abf0946c983ad589902e35ceb9026ef60">mean</a> (const Array&lt; double &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean vector of array "x".  <a href="#abf0946c983ad589902e35ceb9026ef60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Array&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#af52620c3e1c24b07a79433a5ff8810a5">variance</a> (const Array&lt; double &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the variance vector of array "x".  <a href="#af52620c3e1c24b07a79433a5ff8810a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a358701dfdb0a38073546c97ab641bb8b">angle</a> (const Array&lt; double &gt; &amp;x, const Array&lt; double &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle between the vectors "x" and "y".  <a href="#a358701dfdb0a38073546c97ab641bb8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#aba9bcc2edca1f75235f0ab355a97a985">corrcoef</a> (const Array&lt; double &gt; &amp;x, const Array&lt; double &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the coefficient of correlation of the data vectors "x" and "y".  <a href="#aba9bcc2edca1f75235f0ab355a97a985"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Array&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#aa30f87b59d8e027f6dc621afc4a7ed83">corrcoef</a> (const Array&lt; double &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the coefficient of correlation matrix of the data vectors stored in matrix "x".  <a href="#aa30f87b59d8e027f6dc621afc4a7ed83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a371d64240fad4a71cf4536797ede7a09">meanvar</a> (const Array&lt; double &gt; &amp;x, Array&lt; double &gt; &amp;, Array&lt; double &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean and variance values of matrix "x".  <a href="#a371d64240fad4a71cf4536797ede7a09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a7e0b8e509edd20cc23965ecf13c43459">meanvar</a> (const Array&lt; double &gt; &amp;pxA, const Array&lt; double &gt; &amp;xA, double &amp;mA, double &amp;vA, const int startA=-1, const int endA=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean and variance values of 1d-arrays p(x)  <a href="#a7e0b8e509edd20cc23965ecf13c43459"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a437d4802b7879e45892424b725c98569">covariance</a> (const Array&lt; double &gt; &amp;x, const Array&lt; double &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the covariance between the data vectors "x" and "y".  <a href="#a437d4802b7879e45892424b725c98569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Array&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a1e4cab9b3d1cee09566d351056991591">covariance</a> (const Array&lt; double &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the covariance matrix of the data vectors stored in matrix "x".  <a href="#a1e4cab9b3d1cee09566d351056991591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Array&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a200cbb1bd895a9716c05646f697d1ef4">invert</a> (const Array&lt; double &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized inverse matrix of input matrix "A" by using singular value decomposition.  <a href="#a200cbb1bd895a9716c05646f697d1ef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ae723dda9ea41c524c370bf9869cdae31">matMat</a> (Array2D&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array2D&lt; double &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two 2D matrices.  <a href="#ae723dda9ea41c524c370bf9869cdae31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#aaa17d65e289ec4945cc8c1aa1c5be350">matColVec</a> (Array&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns A = BC, where C is viewed as a column vector.  <a href="#aaa17d65e289ec4945cc8c1aa1c5be350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a0d1a54ea22855c60a74375747022a0f0">matColVec</a> (ArrayReference&lt; double &gt; A, const Array2D&lt; double &gt; &amp;B, const ArrayReference&lt; double &gt; C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns A = BC, where C is viewed as a column vector.  <a href="#a0d1a54ea22855c60a74375747022a0f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a7475b6b732c8917c3e07ea76c2e59963">matColVec</a> (Array&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C, unsigned int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$ A = B C_i $" src="form_94.png"/> , where <img class="formulaInl" alt="$ C_i $" src="form_95.png"/> is a column of the matrix C.  <a href="#a7475b6b732c8917c3e07ea76c2e59963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a18749fe8031357354c728203d7a50e28">vecMatVec</a> (const Array&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scalar ABC.  <a href="#a18749fe8031357354c728203d7a50e28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a5dda376d959f56a8673f34147049b84a">vecMatVec</a> (const Array&lt; double &gt; &amp;A, unsigned int i, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C, unsigned int j)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scalar <img class="formulaInl" alt="$ A_i B C_j $" src="form_113.png"/>.  <a href="#a5dda376d959f56a8673f34147049b84a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ac2ca3cbb522e8e3c3650db8a26c67175">invertSymm</a> (Array2D&lt; double &gt; &amp;I, const Array2D&lt; double &gt; &amp;A)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a symmetric matrix.  <a href="#ac2ca3cbb522e8e3c3650db8a26c67175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a1214faaa5d9712f2766730ee9a447e23">invertSymmPositiveDefinite</a> (Array2D&lt; double &gt; &amp;I, const Array2D&lt; double &gt; &amp;ArrSymm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a symmetric positive definite matrix.  <a href="#a1214faaa5d9712f2766730ee9a447e23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#ae910ef90eb9191204601c0d62643b2c1">g_inverse</a> (const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;bmatA, unsigned maxIterations=200, double tolerance=1e-10, bool ignoreThreshold=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the generalized inverse matrix of input matrix "amatA".  <a href="#ae910ef90eb9191204601c0d62643b2c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a6f06c2ae780d82fb3511f41fcbf7e1b6">g_inverseCholesky</a> (const Array2D&lt; double &gt; &amp;A, Array2D&lt; double &gt; &amp;outA, double thresholdFactor=1e-9)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized inverse matrix of input matrix using Cholesky decomposition.  <a href="#a6f06c2ae780d82fb3511f41fcbf7e1b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_alg_8h.html#a50431fcce913cfde903398893b3c713e">g_inverseMoorePenrose</a> (const Array2D&lt; double &gt; &amp;A, Array2D&lt; double &gt; &amp;outA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized inverse matrix of input matrix <img class="formulaInl" alt="$ A $" src="form_114.png"/> using Cholesky decomposition assuming that <img class="formulaInl" alt="$ A^T A $" src="form_60.png"/> has full rank.  <a href="#a50431fcce913cfde903398893b3c713e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Some operations for matrices. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995-01-01</dd></dl>
<dl class="user"><dt><b>Copyright (c) 1999-2001:</b></dt><dd>Institut f&uuml;r Neuroinformatik<br/>
 Ruhr-Universit&auml;t Bochum<br/>
 D-44780 Bochum, Germany<br/>
 Phone: +49-234-32-25558<br/>
 Fax: +49-234-32-14209<br/>
 eMail: <a href="mailto:Shark-admin@neuroinformatik.ruhr-uni-bochum.de">Shark-admin@neuroinformatik.ruhr-uni-bochum.de</a><br/>
 www: <a href="http://www.neuroinformatik.ruhr-uni-bochum.de">http://www.neuroinformatik.ruhr-uni-bochum.de</a><br/>
 <br/>
</dd></dl>
<dl class="user"><dt><b>Project:</b></dt><dd>LinAlg</dd></dl>
<p>This file is part of LinAlg. This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.</p>
<p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this library; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. </p>

<p>Definition in file <a class="el" href="_lin_alg_8h_source.html">LinAlg.h</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a358701dfdb0a38073546c97ab641bb8b"></a><!-- doxytag: member="LinAlg.h::angle" ref="a358701dfdb0a38073546c97ab641bb8b" args="(const Array&lt; double &gt; &amp;x, const Array&lt; double &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double angle </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the angle between the vectors "x" and "y". </p>
<p>Given the two one-dimensional vectors "x" and "y" with the same no. <em>N</em> of elements, the function calculates: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ angle = \frac{\sum_{i=1}^{N} (x_i * y_i)}{\sum_{i=1}^{N} x_i * \sum_{i=1}^{N} y_i} \]" src="form_64.png"/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>one-dimensional vector no. 1 </td></tr>
    <tr><td class="paramname">y</td><td>one-dimensional vector no. 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the angle between <em>x</em> and <em>y</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>x</em> is not one-dimensional or that <em>x</em> has not the same size than <em>y</em> </td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg. &lt; </p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00216">216</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae1a498500ef614caa47ccb6a38cfadd0"></a><!-- doxytag: member="LinAlg.h::CholeskyDecomposition" ref="ae1a498500ef614caa47ccb6a38cfadd0" args="(const Array2D&lt; double &gt; &amp;M, Array2D&lt; double &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lower triangular Cholesky decomposition </p>
<p>Given an <img class="formulaInl" alt="$ m \times m $" src="form_102.png"/> symmetric positive definite matrix <img class="formulaInl" alt="$M$" src="form_103.png"/>, compute the lower triangular matrix <img class="formulaInl" alt="$C$" src="form_104.png"/> such that <img class="formulaInl" alt="$ M=CC^T $" src="form_105.png"/></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td><img class="formulaInl" alt="$ m \times m $" src="form_102.png"/> matrix, which must be symmetric and positive definite </td></tr>
    <tr><td class="paramname">C</td><td><img class="formulaInl" alt="$ m \times m $" src="form_102.png"/> matrix, which stores the Cholesky factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>T. Suttorp and C. Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2008</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00868">868</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00198">invertSymmPositiveDefinite()</a>.</p>

</div>
</div>
<a class="anchor" id="aba9bcc2edca1f75235f0ab355a97a985"></a><!-- doxytag: member="LinAlg.h::corrcoef" ref="aba9bcc2edca1f75235f0ab355a97a985" args="(const Array&lt; double &gt; &amp;x, const Array&lt; double &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double corrcoef </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the coefficient of correlation of the data vectors "x" and "y". </p>
<p>Given two data vectors <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/> of length <img class="formulaInl" alt="$n$" src="form_67.png"/>, the function calculates the coefficient of correlation given as</p>
<p><img class="formulaInl" alt="$ r := \frac{cov(x, y)}{\Delta x \Delta y} $" src="form_68.png"/></p>
<p>where <img class="formulaInl" alt="$cov(x, y)$" src="form_69.png"/> is the covariance between the two vectors (see also <a class="el" href="_lin_alg_8h.html#a437d4802b7879e45892424b725c98569" title="Calculates the covariance between the data vectors &quot;x&quot; and &quot;y&quot;.">covariance(const Array&lt; double &gt;&amp;, const Array&lt; double &gt;&amp;)</a>) and <img class="formulaInl" alt="$\Delta x$" src="form_70.png"/> and <img class="formulaInl" alt="$\Delta y$" src="form_71.png"/> are the standard deviations of <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/> respectively. <br/>
 The coefficient of correlation is used to show the dependence between <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/>. It always holds <img class="formulaInl" alt="$-1 \leq r \leq 1$" src="form_72.png"/> and the greater the value of <img class="formulaInl" alt="$r^2$" src="form_73.png"/> is, the greater is the dependence between <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first data vector. </td></tr>
    <tr><td class="paramname">y</td><td>second data vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the coefficient of correlation. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>x</em> is not one-dimensional or <em>x</em> has not the same size than <em>y</em> </td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00408">408</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa30f87b59d8e027f6dc621afc4a7ed83"></a><!-- doxytag: member="LinAlg.h::corrcoef" ref="aa30f87b59d8e027f6dc621afc4a7ed83" args="(const Array&lt; double &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; double &gt; corrcoef </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the coefficient of correlation matrix of the data vectors stored in matrix "x". </p>
<p>Given a matrix <img class="formulaInl" alt="$X = (x_{ij})$" src="form_74.png"/> of <img class="formulaInl" alt="$n$" src="form_67.png"/> vectors with length <img class="formulaInl" alt="$N$" src="form_45.png"/>, the function calculates the coefficient of correlation matrix given as</p>
<p><img class="formulaInl" alt="$ r := (r_{kl}) \mbox{,\ } r_{kl} = \frac{c_{kl}}{\Delta x_k \Delta x_l}\mbox{,\ } k,l = 1, \dots, N $" src="form_75.png"/></p>
<p>where <img class="formulaInl" alt="$c_{kl}$" src="form_76.png"/> is the entry of the covariance matrix of <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/> (see <a class="el" href="_lin_alg_8h.html#a1e4cab9b3d1cee09566d351056991591" title="Calculates the covariance matrix of the data vectors stored in matrix &quot;x&quot;.">covariance(const Array&lt;double&gt;&amp; x)</a>) and <img class="formulaInl" alt="$\Delta x_k$" src="form_77.png"/> and <img class="formulaInl" alt="$\Delta x_l$" src="form_78.png"/> are the standard deviations of <img class="formulaInl" alt="$x_k$" src="form_79.png"/> and <img class="formulaInl" alt="$x_l$" src="form_80.png"/> respectively.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <img class="formulaInl" alt="$n \times N$" src="form_81.png"/> input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <img class="formulaInl" alt="$N \times N$" src="form_82.png"/> coefficient of correlation matrix. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>x</em> is only one- or non-dimensional</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00483">483</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>References <a class="el" href="_lin_alg_8cpp_source.html#l00542">covariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e4cab9b3d1cee09566d351056991591"></a><!-- doxytag: member="LinAlg.h::covariance" ref="a1e4cab9b3d1cee09566d351056991591" args="(const Array&lt; double &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; double &gt; covariance </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the covariance matrix of the data vectors stored in matrix "x". </p>
<p>Given a matrix <img class="formulaInl" alt="$X = (x_{ij})$" src="form_74.png"/> of <img class="formulaInl" alt="$n$" src="form_67.png"/> vectors with length <img class="formulaInl" alt="$N$" src="form_45.png"/>, the function calculates the covariance matrix given as</p>
<p><img class="formulaInl" alt="$ Cov = (c_{kl}) \mbox{,\ } c_{kl} = \frac{1}{n - 1} \sum_{i=1}^n (x_{ik} - \overline{x_k})(x_{il} - \overline{x_l})\mbox{,\ } k,l = 1, \dots, N $" src="form_88.png"/></p>
<p>where <img class="formulaInl" alt="$\overline{x_j} = \frac{1}{n} \sum_{i = 1}^n x_{ij}$" src="form_89.png"/> is the mean value of <img class="formulaInl" alt="$x_j \mbox{,\ }j = 1, \dots, N$" src="form_90.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <img class="formulaInl" alt="$n \times N$" src="form_81.png"/> input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><img class="formulaInl" alt="$N \times N$" src="form_82.png"/> matrix of covariance values. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "type mismatch" and indicates that <em>x</em> is not 2-dimensional</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00602">602</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>References <a class="el" href="_lin_alg_8cpp_source.html#l00103">mean()</a>.</p>

</div>
</div>
<a class="anchor" id="a437d4802b7879e45892424b725c98569"></a><!-- doxytag: member="LinAlg.h::covariance" ref="a437d4802b7879e45892424b725c98569" args="(const Array&lt; double &gt; &amp;x, const Array&lt; double &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double covariance </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the covariance between the data vectors "x" and "y". </p>
<p>Given two data vectors <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/> with length <img class="formulaInl" alt="$n$" src="form_67.png"/>, interpreted as <img class="formulaInl" alt="$n$" src="form_67.png"/> points <img class="formulaInl" alt="$(x_i, y_i)$" src="form_83.png"/> with <img class="formulaInl" alt="$i = 1, \dots, n$" src="form_84.png"/>, the function calculates the covariance given as</p>
<p><img class="formulaInl" alt="$ cov = \frac{1}{n - 1} \sum_{i = 1}^n (x_i - \overline{x}) (y_i - \overline{y}) $" src="form_85.png"/></p>
<p>where <img class="formulaInl" alt="$\overline{x}$" src="form_86.png"/> and <img class="formulaInl" alt="$\overline{y}$" src="form_87.png"/> are the mean values of <img class="formulaInl" alt="$x$" src="form_65.png"/> and <img class="formulaInl" alt="$y$" src="form_66.png"/> respectively.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first data vector. </td></tr>
    <tr><td class="paramname">y</td><td>second data vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the covariance matrix. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "type mismatch" and indicates that <em>x</em> is not one-dimensional or <em>x</em> has not the same size than <em>y</em> </td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00542">542</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>Referenced by <a class="el" href="_lin_alg_8cpp_source.html#l00483">corrcoef()</a>.</p>

</div>
</div>
<a class="anchor" id="a44ada29d9de0ab64d3dc6cd1ca91e47f"></a><!-- doxytag: member="LinAlg.h::detsymm" ref="a44ada29d9de0ab64d3dc6cd1ca91e47f" args="(Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double detsymm </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the determinant of the symmetric matrix "amatA". </p>
<p>Calculates the determinant of the symmetric matrix "amatA".</p>
<p>Calculates the determinate of matrix <em>amatA</em> by using its <em>n</em> eigenvalues <img class="formulaInl" alt="$ x_j $" src="form_17.png"/> that first will be calculated. The determinate is then given as:</p>
<p><img class="formulaInl" alt="$ \prod_{j=1}^n x_j $" src="form_18.png"/></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which is symmetric, so only the bottom triangular matrix must contain values. At the end of the function <em>amatA</em> always contains the full matrix. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, that will contain the scaled eigenvectors at the end of the function. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector that will contain the eigenvalues at the end of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The determinate of matrix <em>amatA</em>. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the eception will be "size mismatch" and indicates that <em>amatA</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>2003/10/02 by S. Wiegand due to name change of 'eigensymm';</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="detsymm_8cpp_source.html#l00094">94</a> of file <a class="el" href="detsymm_8cpp_source.html">detsymm.cpp</a>.</p>

<p>References <a class="el" href="eigensymm_8cpp_source.html#l00098">eigensymm_intermediate()</a>.</p>

<p>Referenced by <a class="el" href="_vec_mat_8cpp_source.html#l00259">Matrix::detSymm()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b1705b71b00806be6951614c700abf0"></a><!-- doxytag: member="LinAlg.h::diagonal" ref="a9b1705b71b00806be6951614c700abf0" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; T &gt; diagonal </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="linalg_simple_test_8cpp-example.html#a4">linalg_simple_test.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_lin_alg_8h_source.html#l00406">406</a> of file <a class="el" href="_lin_alg_8h_source.html">LinAlg.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1a847ab3c268fb6f5531a22656cc0c6"></a><!-- doxytag: member="LinAlg.h::discrimAnalysis" ref="ac1a847ab3c268fb6f5531a22656cc0c6" args="(Array2D&lt; double &gt; &amp;betweenCovarA, Array2D&lt; double &gt; &amp;withinCovarA, Array2D&lt; double &gt; &amp;transMatA, Array&lt; double &gt; &amp;dvecA, unsigned &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void discrimAnalysis </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>betweenCovarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>withinCovarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>transMatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given "m" classes of data, the covariances between the values within one class and the covariances between all the classes, this method calculates the transformation matrix that will project the data in a way, that maximum separation of the different classes is given. </p>

</div>
</div>
<a class="anchor" id="a139c942be3ee988a6ac301a2252f186c"></a><!-- doxytag: member="LinAlg.h::eigen" ref="a139c942be3ee988a6ac301a2252f186c" args="(Array&lt; double &gt; A, Array&lt; double &gt; &amp;vr, Array&lt; double &gt; &amp;vi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigen </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double &gt;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the eigenvalues of an arbitrary matrix "amatA" by balancing the elements of the matrix, then reducing it to an upper Hessenberg matrix and finally calculating the eigenvalues ot the reduced form. </p>
<p>Given a <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>A</em>, this function calculates the eigenvalues <img class="formulaInl" alt="$ \lambda $" src="form_23.png"/> defined as (<em>x</em> is the corresponding but not calculated eigenvector)</p>
<p><img class="formulaInl" alt="$ Ax = \lambda x $" src="form_27.png"/></p>
<p>where <em>x</em> is a one-column matrix and the matrix multiplication is used for <em>A</em> and <em>x</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix. </td></tr>
    <tr><td class="paramname">vr</td><td>real parts of eigenvalues </td></tr>
    <tr><td class="paramname">vi</td><td>imaginary parts of eigenvalues</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>amatA</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Changes</b></dt><dd>previously 'eigensymm', renamed by S. Wiegand 2003/10/01</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigen_8cpp_source.html#l00576">576</a> of file <a class="el" href="eigen_8cpp_source.html">eigen.cpp</a>.</p>

<p>References <a class="el" href="eigen_8cpp_source.html#l00120">Balanc()</a>, and <a class="el" href="eigen_8cpp_source.html#l00252">ElmHes()</a>.</p>

<p>Referenced by <a class="el" href="_vec_mat_8cpp_source.html#l00242">Matrix::eigenvalues()</a>.</p>

</div>
</div>
<a class="anchor" id="a19601b671142e21554e4709521fddb51"></a><!-- doxytag: member="LinAlg.h::eigenerr" ref="a19601b671142e21554e4709521fddb51" args="(const Array2D&lt; double &gt; &amp;amatA, const Array2D&lt; double &gt; &amp;vmatA, const Array&lt; double &gt; &amp;dvecA, unsigned c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double eigenerr </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the relative error of eigenvalue no. "c". </p>
<p>Calculates the relative error of eigenvalue no. "c".</p>
<p>Given a symmetric <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>amatA</em>, the matrix <em>vmatA</em> of its eigenvectors and the vector <em>dvecA</em> of the corresponding eigenvalues, this function calculates the relative error of one eigenvalue, denoted by the no. <em>c</em>. If we have a <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>A</em>, a matrix <em>x</em> of eigenvectors and a vector <img class="formulaInl" alt="$ \lambda $" src="form_23.png"/> of corresponding eigenvalues, the relative error of eigenvalue no. <em>c</em> is calculated as</p>
<p><img class="formulaInl" alt="$ \sqrt{\sum_{i=0}^n \left(\sum_{j=0}^n A(i,j) \ast x(j,c) - x(i,c) \ast \lambda(c) \right)^2} $" src="form_28.png"/></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which has to be symmetric, so only the lower triangular matrix must contain values. The matrix is not changed by the function. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with normalized eigenvectors, each column contains an eigenvector. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with eigenvalues in descending order. </td></tr>
    <tr><td class="paramname">c</td><td>No. of the considered eigenvalue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the relative error. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>dvecA</em> is not one-dimensional or that <em>amatA</em> or <em>vmatA</em> don't have the same number of rows or columns as <em>dvecA</em> contains number of values</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigenerr_8cpp_source.html#l00094">94</a> of file <a class="el" href="eigenerr_8cpp_source.html">eigenerr.cpp</a>.</p>

<p>Referenced by <a class="el" href="rank_8cpp_source.html#l00088">sym_rank()</a>.</p>

</div>
</div>
<a class="anchor" id="aa85867998d5a6b2ca11626cda4dde9d5"></a><!-- doxytag: member="LinAlg.h::eigensort" ref="aa85867998d5a6b2ca11626cda4dde9d5" args="(Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensort </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts the eigenvalues in vector "dvecA" in descending order and the corresponding eigenvectors in matrix "vmatA". </p>
<p>Sorts the eigenvalues in vector "dvecA" in descending order and the corresponding eigenvectors in matrix "vmatA".</p>
<p>Given the matrix <em>vmatA</em> of eigenvectors and the vector <em>dvecA</em> of corresponding eigenvalues, the values in <em>dvecA</em> will be sorted by descending order and the eigenvectors in <em>vmatA</em> will change their places in a way, that at the end of the function an eigenvalue at position <em>j</em> of vector <em>dvecA</em> will belong to the eigenvector at column <em>j</em> of matrix <em>vmatA</em>. If we've got for example the following result after calling the function:</p>
<p><img class="formulaInl" alt="$ \begin{array}{*{3}{r}} v_{11} &amp; v_{21} &amp; v_{31}\\ v_{12} &amp; v_{22} &amp; v_{32}\\ v_{13} &amp; v_{23} &amp; v_{33}\\ &amp; &amp; \\ v_1 &amp; v_2 &amp; v_3\\ \end{array} $" src="form_29.png"/></p>
<p>then eigenvalue <img class="formulaInl" alt="$ v_1 $" src="form_30.png"/> has the corresponding eigenvector <img class="formulaInl" alt="$ ( v_{11}\ v_{12}\ v_{13} ) $" src="form_31.png"/> and <img class="formulaInl" alt="$ v_1 > v_2 > v_3 $" src="form_32.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with eigenvectors (each column contains an eigenvector, corresponding to one eigenvalue). </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with eigenvalues, will contain the eigenvalues in descending order when returning from the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>dvecA</em> is not one-dimensional or that the number of rows or the number of columns in <em>vmatA</em> is different from the number of values in <em>dvecA</em> </td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigensort_8cpp_source.html#l00100">100</a> of file <a class="el" href="eigensort_8cpp_source.html">eigensort.cpp</a>.</p>

<p>Referenced by <a class="el" href="eigensymm_8cpp_source.html#l00556">eigensymm()</a>, <a class="el" href="eigensymm_8cpp_source.html#l00098">eigensymm_intermediate()</a>, <a class="el" href="eigensymm_jacobi_8cpp_source.html#l00125">eigensymmJacobi()</a>, and <a class="el" href="eigensymm_jacobi2_8cpp_source.html#l00098">eigensymmJacobi2()</a>.</p>

</div>
</div>
<a class="anchor" id="a4740d207478277949f92864c6c36c648"></a><!-- doxytag: member="LinAlg.h::eigensymm" ref="a4740d207478277949f92864c6c36c648" args="(const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymm </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used as frontend for <a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140" title="Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix &quot;amatA&quot; us...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA,Array&lt;double&gt; &amp;odvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "amatA" during application. </p>
<p>Each time this frontend is called additional memory is allocated for intermediate results.</p>
<p>Used as frontend for <a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140" title="Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix &quot;amatA&quot; us...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA,Array&lt;double&gt; &amp;odvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "amatA" during application.</p>
<p>Frontend for function <a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140" title="Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix &quot;amatA&quot; us...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA,Array&lt;double&gt; &amp;odvecA)</a>, when memory for 'odvecA' should be allocated by the call of this frontend.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which must be symmetric, so only the bottom triangular matrix must contain values. </td></tr>
    <tr><td class="paramname">G</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with the calculated normalized eigenvectors, each column will contain one eigenvector. </td></tr>
    <tr><td class="paramname">l</td><td>n-dimensional vector with the calculated eigenvalues in descending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>S. Wiegand </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2003</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigensymm_8cpp_source.html#l00426">426</a> of file <a class="el" href="eigensymm_8cpp_source.html">eigensymm.cpp</a>.</p>

<p>References <a class="el" href="eigensymm_8cpp_source.html#l00426">eigensymm()</a>.</p>

<p>Referenced by <a class="el" href="eigensymm_8cpp_source.html#l00426">eigensymm()</a>, and <a class="el" href="_lin_alg_8cpp_source.html#l00824">invertSymm()</a>.</p>

</div>
</div>
<a class="anchor" id="a218cdfe4b0bbc068317ee65caad3cd11"></a><!-- doxytag: member="LinAlg.h::eigensymm" ref="a218cdfe4b0bbc068317ee65caad3cd11" args="(const Array&lt; double &gt; &amp;A, Array&lt; double &gt; &amp;G, Array&lt; double &gt; &amp;l, Array&lt; double &gt; &amp;od)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymm </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>od</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used as frontend for <a class="el" href="_lin_alg_8h.html#ac4ac4221d20c0560656c7582295a2140" title="Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix &quot;amatA&quot; us...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA,Array&lt;double&gt; &amp;odvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "A" during application. </p>

</div>
</div>
<a class="anchor" id="ab030e103592a6769e7848d27c0b9bdaa"></a><!-- doxytag: member="LinAlg.h::eigensymm" ref="ab030e103592a6769e7848d27c0b9bdaa" args="(const Array&lt; double &gt; &amp;A, Array&lt; double &gt; &amp;G, Array&lt; double &gt; &amp;l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymm </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used as another frontend for <a class="el" href="_lin_alg_8h.html#a4740d207478277949f92864c6c36c648" title="Used as frontend for eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmat...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA)</a> for calculating the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction without corrupting "A" during application. </p>
<p>Each time this frontend is called additional memory is allocated for intermediate results. </p>

</div>
</div>
<a class="anchor" id="ac4ac4221d20c0560656c7582295a2140"></a><!-- doxytag: member="LinAlg.h::eigensymm" ref="ac4ac4221d20c0560656c7582295a2140" args="(const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA, Array&lt; double &gt; &amp;odvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymm </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>odvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction. </p>
<p>This method works without corrupting "amatA" during application by demanding another Array 'odvecA' as an algorithmic buffer instead of using the last row of 'amatA' to store intermediate algorithmic results.</p>
<p>Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction.</p>
<p>Given a symmetric <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>A</em>, this function calculates the eigenvalues <img class="formulaInl" alt="$ \lambda $" src="form_23.png"/> and the eigenvectors <em>x</em>, defined as</p>
<p><img class="formulaInl" alt="$ Ax = \lambda x $" src="form_27.png"/></p>
<p>where <em>x</em> is a one-column matrix and the matrix multiplication is used for <em>A</em> and <em>x</em>. Here, the Givens reduction as a modification of the Jacobi method (s.a. <a class="el" href="_lin_alg_8h.html#acd05caa966d2ee1bf5f85fb8d4360d4a" title="Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix &quot;amatA&quot; ...">eigensymmJacobi</a>) is used. Instead of trying to reduce the matrix all the way to diagonal form, we are content to stop when the matrix is tridiagonal. This allows the function to be carried out in a finite number of steps, unlike the Jacobi method, which requires iteration to convergence. So in comparison to the Jacobi method, this function is faster for matrices with an order greater than 10.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which must be symmetric, so only the bottom triangular matrix must contain values. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with the calculated normalized eigenvectors, each column will contain an eigenvector. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with the calculated eigenvalues in descending order. </td></tr>
    <tr><td class="paramname">odvecA</td><td>n-dimensional vector with the calculated offdiagonal of the Householder transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>2003/09/19 18:55:22 S. Wiegand lower triangular part of 'amatA' will not corrupted anymore</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigensymm_8cpp_source.html#l00556">556</a> of file <a class="el" href="eigensymm_8cpp_source.html">eigensymm.cpp</a>.</p>

<p>References <a class="el" href="eigensort_8cpp_source.html#l00100">eigensort()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7c3faaaece1bcbea6d04e1939c7d9f2"></a><!-- doxytag: member="LinAlg.h::eigensymm_intermediate" ref="ac7c3faaaece1bcbea6d04e1939c7d9f2" args="(const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;hmatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymm_intermediate </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction, however, "hmatA" contains intermediate results after application. </p>
<p>Calculates the eigenvalues and the normalized eigenvectors of a symmetric matrix "amatA" using the Givens and Householder reduction, however, "hmatA" contains intermediate results after application.</p>
<p>Given a symmetric <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>A</em>, this function calculates the eigenvalues <img class="formulaInl" alt="$ \lambda $" src="form_23.png"/> and the eigenvectors <em>x</em>, defined as</p>
<p><img class="formulaInl" alt="$ Ax = \lambda x $" src="form_27.png"/></p>
<p>where <em>x</em> is a one-column matrix and the matrix multiplication is used for <em>A</em> and <em>x</em>. Here, the Givens reduction as a modification of the Jacobi method (s.a. <a class="el" href="_lin_alg_8h.html#acd05caa966d2ee1bf5f85fb8d4360d4a" title="Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix &quot;amatA&quot; ...">eigensymmJacobi</a>) is used. Instead of trying to reduce the matrix all the way to diagonal form, we are content to stop when the matrix is tridiagonal. This allows the function to be carried out in a finite number of steps, unlike the Jacobi method, which requires iteration to convergence. So in comparison to the Jacobi method, this function is faster for matrices with an order greater than 10.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which must be symmetric, so only the bottom triangular matrix must contain values. Values below the diagonal will be destroyed. The method uses this matrix as a buffer for intermediate results. </td></tr>
    <tr><td class="paramname">hmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, that is used to store intermediate results (other methods like detsymm use these for further calculations) </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with the calculated normalized eigenvectors, each column will contain an eigenvector. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with the calculated eigenvalues in descending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>previously 'eigensymm', renamed by S. Wiegand 2003/10/01</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigensymm_8cpp_source.html#l00098">98</a> of file <a class="el" href="eigensymm_8cpp_source.html">eigensymm.cpp</a>.</p>

<p>References <a class="el" href="eigensort_8cpp_source.html#l00100">eigensort()</a>.</p>

<p>Referenced by <a class="el" href="detsymm_8cpp_source.html#l00094">detsymm()</a>, <a class="el" href="detsymm_8cpp_source.html#l00176">logdetsymm()</a>, and <a class="el" href="rank_decomp_8cpp_source.html#l00093">rankDecomp()</a>.</p>

</div>
</div>
<a class="anchor" id="acd05caa966d2ee1bf5f85fb8d4360d4a"></a><!-- doxytag: member="LinAlg.h::eigensymmJacobi" ref="acd05caa966d2ee1bf5f85fb8d4360d4a" args="(Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymmJacobi </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix "amatA" using the Jacobi method. </p>
<p>Given a symmetric <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>A</em>, this function calculates the eigenvalues <img class="formulaInl" alt="$ \lambda $" src="form_23.png"/> and the eigenvectors <em>x</em>, defined as</p>
<p><img class="formulaInl" alt="$ Ax = \lambda x $" src="form_27.png"/></p>
<p>where <em>x</em> is a one-column matrix and the matrix multiplication is used for <em>A</em> and <em>x</em>. For the calculation of the eigenvectors and eigenvalues the so called Jacobi rotation is used to annihilate one of the off-diagonal elements with the basic Jacobi rotation given as matrix of the form</p>
<p><img class="formulaInl" alt="$ P_{pq} = \left( \begin{array}{*{7}{c}} 1 \\ &amp; \dots \\ &amp; &amp; c &amp; \dots &amp; s \\ &amp; &amp; \vdots &amp; 1 &amp; \vdots \\ &amp; &amp; -s &amp; \dots &amp; c \\ &amp; &amp; &amp; &amp; &amp; \dots \\ &amp; &amp; &amp; &amp; &amp; &amp; 1 \\ \end{array} \right) $" src="form_33.png"/></p>
<p>In this matrix all the diagonal elements are unity except for the two elemnts <em>c</em> in rows (and columns) <em>p</em> and <em>q</em>. All off-diagonal elements are zero except the two elements <em>s</em> and - <em>s</em>. The numbers <em>c</em> and <em>s</em> are the cosine of a rotation angle <img class="formulaInl" alt="$ \Phi $" src="form_34.png"/>, so <img class="formulaInl" alt="$ c^2 + s^2 = 1$" src="form_35.png"/>. Successive rotations lead to the off-diagonal elements getting smaller and smaller, until the matrix is diagonal to machine precision. Accumulating the product of the transformations as you go gives the matrix of eigenvectors, while the elements of the final diagonal matrix are the eigenvalues. Use this function for the calculation of the eigenvalues and eigenvectors for matrices <em>amatA</em> with moderate order not greater than 10.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which must be symmetric, so only the upper triangular matrix must contain values. Values above the diagonal will be destroyed. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with the calculated normalized eigenvectors, each column will contain an eigenvector. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with the calculated eigenvalues in descending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigensymm_jacobi_8cpp_source.html#l00125">125</a> of file <a class="el" href="eigensymm_jacobi_8cpp_source.html">eigensymmJacobi.cpp</a>.</p>

<p>References <a class="el" href="eigensort_8cpp_source.html#l00100">eigensort()</a>.</p>

</div>
</div>
<a class="anchor" id="ab11a543dec385422cc31d628396e9c7a"></a><!-- doxytag: member="LinAlg.h::eigensymmJacobi2" ref="ab11a543dec385422cc31d628396e9c7a" args="(Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigensymmJacobi2 </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix "amatA" using a modified Jacobi method. </p>
<p>Given a symmetric <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>A</em>, this function calculates the eigenvalues <img class="formulaInl" alt="$ \lambda $" src="form_23.png"/> and the eigenvectors <em>x</em>, defined as</p>
<p><img class="formulaInl" alt="$ Ax = \lambda x $" src="form_27.png"/></p>
<p>where <em>x</em> is a one-column matrix and the matrix multiplication is used for <em>A</em> and <em>x</em>. This function uses the Jacobi method as in <a class="el" href="_lin_alg_8h.html#acd05caa966d2ee1bf5f85fb8d4360d4a" title="Calculates the eigenvalues and the normalized eigenvectors of the symmetric matrix &quot;amatA&quot; ...">eigensymmJacobi</a>, but the method is modificated after J. von Neumann to avoid convergence problems when dealing with low machine precision.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which must be symmetric, so only the bottom triangular matrix must contain values. Values below the diagonal will be destroyed. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with the calculated normalized eigenvectors, each column will contain one eigenvector. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with the calculated eigenvalues in descending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>amatA</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="eigensymm_jacobi2_8cpp_source.html#l00098">98</a> of file <a class="el" href="eigensymm_jacobi2_8cpp_source.html">eigensymmJacobi2.cpp</a>.</p>

<p>References <a class="el" href="eigensort_8cpp_source.html#l00100">eigensort()</a>.</p>

</div>
</div>
<a class="anchor" id="ae910ef90eb9191204601c0d62643b2c1"></a><!-- doxytag: member="LinAlg.h::g_inverse" ref="ae910ef90eb9191204601c0d62643b2c1" args="(const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;bmatA, unsigned maxIterations=200, double tolerance=1e&#45;10, bool ignoreThreshold=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned g_inverse </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>bmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the generalized inverse matrix of input matrix "amatA". </p>
<p>Given an input matrix <img class="formulaInl" alt="$ X $" src="form_54.png"/> this function uses singular value decomposition to determine the generalized inverse matrix <img class="formulaInl" alt="$ X' $" src="form_55.png"/>, so that</p>
<p><img class="formulaInl" alt="$ XX'X = X $" src="form_56.png"/></p>
<p>If <img class="formulaInl" alt="$ X $" src="form_54.png"/> is singular, i.e. <img class="formulaInl" alt="$ det(X) = 0 $" src="form_57.png"/> or <img class="formulaInl" alt="$ X $" src="form_54.png"/> is non-square then <img class="formulaInl" alt="$ X' $" src="form_55.png"/> is not unique.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> input matrix. </td></tr>
    <tr><td class="paramname">bmatA</td><td><img class="formulaInl" alt="$ n \times m $" src="form_59.png"/> generalized inverse matrix. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>Number of iterations after which the SVD calculation algorithm gives up, if the solution has still not converged. Default ist 200 Iterations. </td></tr>
    <tr><td class="paramname">tolerance</td><td>singular values less than this value will be considered zero. Default is 1e-10. </td></tr>
    <tr><td class="paramname">ignoreThreshold</td><td>If set to false, the method throws an exception if the threshold maxIterations is exceeded. Otherwise it uses the approximate intermediate results in the further calculations. The default is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none.</dd></dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svd_8cpp.html" title="Used for singular value decomposition of rectangular and square matrices.">svd.cpp</a> </dd></dl>

<p>Definition at line <a class="el" href="g__inverse_8cpp_source.html#l00091">91</a> of file <a class="el" href="g__inverse_8cpp_source.html">g_inverse.cpp</a>.</p>

<p>References <a class="el" href="svd_8cpp_source.html#l00110">svd()</a>, <a class="el" href="svdrank_8cpp_source.html#l00096">svdrank()</a>, and <a class="el" href="svdsort_8cpp_source.html#l00091">svdsort()</a>.</p>

<p>Referenced by <a class="el" href="_vec_mat_8cpp_source.html#l00190">Matrix::inverse()</a>, and <a class="el" href="invert_8cpp_source.html#l00078">invert()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f06c2ae780d82fb3511f41fcbf7e1b6"></a><!-- doxytag: member="LinAlg.h::g_inverseCholesky" ref="a6f06c2ae780d82fb3511f41fcbf7e1b6" args="(const Array2D&lt; double &gt; &amp;A, Array2D&lt; double &gt; &amp;outA, double thresholdFactor=1e&#45;9)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void g_inverseCholesky </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>outA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the generalized inverse matrix of input matrix using Cholesky decomposition. </p>
<p>Returns the generalized inverse matrix of input matrix using Cholesky decomposition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The generalized inverse matrix. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">check_exception</td><td>the type of the exception will be "size mismatch" and indicates that <em>A</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>T. Suttorp </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2008</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="g__inverse_8cpp_source.html#l00254">254</a> of file <a class="el" href="g__inverse_8cpp_source.html">g_inverse.cpp</a>.</p>

<p>References <a class="el" href="_lin_alg_8cpp_source.html#l00824">invertSymm()</a>, <a class="el" href="g__inverse_8cpp_source.html#l00198">invertSymmPositiveDefinite()</a>, <a class="el" href="_lin_alg_8cpp_source.html#l00641">matMat()</a>, and <a class="el" href="_lin_alg_8h_source.html#l00341">transpose()</a>.</p>

<p>Referenced by <a class="el" href="_vec_mat_8cpp_source.html#l00198">Matrix::inverseCholesky()</a>.</p>

</div>
</div>
<a class="anchor" id="a50431fcce913cfde903398893b3c713e"></a><!-- doxytag: member="LinAlg.h::g_inverseMoorePenrose" ref="a50431fcce913cfde903398893b3c713e" args="(const Array2D&lt; double &gt; &amp;A, Array2D&lt; double &gt; &amp;outA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void g_inverseMoorePenrose </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>outA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the generalized inverse matrix of input matrix <img class="formulaInl" alt="$ A $" src="form_114.png"/> using Cholesky decomposition assuming that <img class="formulaInl" alt="$ A^T A $" src="form_60.png"/> has full rank. </p>
<p>Returns the generalized inverse matrix of input matrix <img class="formulaInl" alt="$ A $" src="form_114.png"/> using Cholesky decomposition assuming that <img class="formulaInl" alt="$ A^T A $" src="form_60.png"/> has full rank.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The generalized inverse matrix. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">check_exception</td><td>the type of the exception will be "size mismatch" and indicates that <em>A</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>T. Suttorp </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2008</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="g__inverse_8cpp_source.html#l00364">364</a> of file <a class="el" href="g__inverse_8cpp_source.html">g_inverse.cpp</a>.</p>

<p>References <a class="el" href="g__inverse_8cpp_source.html#l00198">invertSymmPositiveDefinite()</a>, <a class="el" href="_lin_alg_8cpp_source.html#l00641">matMat()</a>, and <a class="el" href="_lin_alg_8h_source.html#l00341">transpose()</a>.</p>

<p>Referenced by <a class="el" href="_vec_mat_8cpp_source.html#l00206">Matrix::inverseMoorePenrose()</a>.</p>

</div>
</div>
<a class="anchor" id="a200cbb1bd895a9716c05646f697d1ef4"></a><!-- doxytag: member="LinAlg.h::invert" ref="a200cbb1bd895a9716c05646f697d1ef4" args="(const Array&lt; double &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; double &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the generalized inverse matrix of input matrix "A" by using singular value decomposition. </p>
<p>Used as frontend for metod <a class="el" href="_lin_alg_8h.html#ae910ef90eb9191204601c0d62643b2c1" title="Calculates the generalized inverse matrix of input matrix &quot;amatA&quot;.">g_inverse</a> when using type "Array" instead of "Array2D".</p>
<p>Returns the generalized inverse matrix of input matrix "A" by using singular value decomposition.</p>
<p>For a more exact description see documentation of method <a class="el" href="_lin_alg_8h.html#ae910ef90eb9191204601c0d62643b2c1" title="Calculates the generalized inverse matrix of input matrix &quot;amatA&quot;.">g_inverse</a>. Here not only the usage of variable type "Array&lt; double &gt;" instead of "Array2D&lt; double &gt;" as storage for matrices is different, but also the resulting generalized inverse matrix is returned directly and not given back by assigning it to a second parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The generalized inverse matrix. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>A</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="g__inverse_8cpp.html" title="Determines the generalized inverse matrix of an input matrix by using singular value decomposition...">g_inverse.cpp</a>, <a class="el" href="svd_8cpp.html" title="Used for singular value decomposition of rectangular and square matrices.">svd.cpp</a> </dd></dl>

<p>Definition at line <a class="el" href="invert_8cpp_source.html#l00078">78</a> of file <a class="el" href="invert_8cpp_source.html">invert.cpp</a>.</p>

<p>References <a class="el" href="g__inverse_8cpp_source.html#l00091">g_inverse()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2ca3cbb522e8e3c3650db8a26c67175"></a><!-- doxytag: member="LinAlg.h::invertSymm" ref="ac2ca3cbb522e8e3c3650db8a26c67175" args="(Array2D&lt; double &gt; &amp;I, const Array2D&lt; double &gt; &amp;A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invertSymm </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts a symmetric matrix. </p>
<p>Inverts a symmetric matrix.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>C. Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00824">824</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>References <a class="el" href="eigensymm_8cpp_source.html#l00426">eigensymm()</a>, and <a class="el" href="_lin_alg_8h_source.html#l00341">transpose()</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00254">g_inverseCholesky()</a>, and <a class="el" href="_vec_mat_8cpp_source.html#l00214">Matrix::inverseSymm()</a>.</p>

</div>
</div>
<a class="anchor" id="a1214faaa5d9712f2766730ee9a447e23"></a><!-- doxytag: member="LinAlg.h::invertSymmPositiveDefinite" ref="a1214faaa5d9712f2766730ee9a447e23" args="(Array2D&lt; double &gt; &amp;I, const Array2D&lt; double &gt; &amp;ArrSymm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invertSymmPositiveDefinite </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ArrSymm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts a symmetric positive definite matrix. </p>

<p>Definition at line <a class="el" href="g__inverse_8cpp_source.html#l00198">198</a> of file <a class="el" href="g__inverse_8cpp_source.html">g_inverse.cpp</a>.</p>

<p>References <a class="el" href="_lin_alg_8cpp_source.html#l00868">CholeskyDecomposition()</a>, and <a class="el" href="_lin_alg_8cpp_source.html#l00641">matMat()</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00254">g_inverseCholesky()</a>, <a class="el" href="g__inverse_8cpp_source.html#l00364">g_inverseMoorePenrose()</a>, and <a class="el" href="_vec_mat_8cpp_source.html#l00222">Matrix::inverseSymmPositiveDefinite()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c2904a5d984482d5e4f49f8854f7520"></a><!-- doxytag: member="LinAlg.h::linearRegress" ref="a4c2904a5d984482d5e4f49f8854f7520" args="(Array2D&lt; double &gt; &amp;cxxMatA, Array2D&lt; double &gt; &amp;cxyMatA, Array&lt; double &gt; &amp;mxVecA, Array&lt; double &gt; &amp;myVecA, Array2D&lt; double &gt; &amp;amatA, Array&lt; double &gt; &amp;bvecA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearRegress </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cxxMatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cxyMatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mxVecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>myVecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given the correlations of the n-dimensional data vector "x" and the m-dimensional data vector "y" and also given their mean values, this function summarizes the data by finding a linear mapping that will approximate the data. </p>

</div>
</div>
<a class="anchor" id="a22e15a9ee0c067a8d392ded500a8f509"></a><!-- doxytag: member="LinAlg.h::logdetsymm" ref="a22e15a9ee0c067a8d392ded500a8f509" args="(Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double logdetsymm </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the log of the determinant of the symmetric matrix "amatA". </p>
<p>Calculates the log of the determinant of the symmetric matrix "amatA".</p>
<p>Calculates the logarithm of the determinate of matrix <em>amatA</em> by using its <em>n</em> eigenvalues <img class="formulaInl" alt="$ x_j $" src="form_17.png"/> that first will be calculated. The determinate is then given as:</p>
<p><img class="formulaInl" alt="$ \prod_{j=1}^n x_j $" src="form_18.png"/></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which is symmetric, so only the bottom triangular matrix must contain values. At the end of the function <em>amatA</em> always contains the full matrix. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, that will contain the scaled eigenvectors at the end of the function. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector that will contain the eigenvalues at the end of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The logarithm of the determinate of matrix <em>amatA</em>. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the eception will be "size mismatch" and indicates that <em>amatA</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>C.Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="detsymm_8cpp_source.html#l00176">176</a> of file <a class="el" href="detsymm_8cpp_source.html">detsymm.cpp</a>.</p>

<p>References <a class="el" href="eigensymm_8cpp_source.html#l00098">eigensymm_intermediate()</a>.</p>

<p>Referenced by <a class="el" href="_vec_mat_8cpp_source.html#l00269">Matrix::logDetSymm()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d1a54ea22855c60a74375747022a0f0"></a><!-- doxytag: member="LinAlg.h::matColVec" ref="a0d1a54ea22855c60a74375747022a0f0" args="(ArrayReference&lt; double &gt; A, const Array2D&lt; double &gt; &amp;B, const ArrayReference&lt; double &gt; C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matColVec </td>
          <td>(</td>
          <td class="paramtype">ArrayReference&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayReference&lt; double &gt;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns A = BC, where C is viewed as a column vector. </p>
<p>Returns A = BC, where C is viewed as a column vector.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>T. Glasmachers </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2008 </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00692">692</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7475b6b732c8917c3e07ea76c2e59963"></a><!-- doxytag: member="LinAlg.h::matColVec" ref="a7475b6b732c8917c3e07ea76c2e59963" args="(Array&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C, unsigned int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matColVec </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <img class="formulaInl" alt="$ A = B C_i $" src="form_94.png"/> , where <img class="formulaInl" alt="$ C_i $" src="form_95.png"/> is a column of the matrix C. </p>
<p>Returns <img class="formulaInl" alt="$ A = B C_i $" src="form_94.png"/> , where <img class="formulaInl" alt="$ C_i $" src="form_95.png"/> is a column of the matrix C.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>T. Glasmachers </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00723">723</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa17d65e289ec4945cc8c1aa1c5be350"></a><!-- doxytag: member="LinAlg.h::matColVec" ref="aaa17d65e289ec4945cc8c1aa1c5be350" args="(Array&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matColVec </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns A = BC, where C is viewed as a column vector. </p>
<p>Returns A = BC, where C is viewed as a column vector.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>C. Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007 </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00665">665</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae723dda9ea41c524c370bf9869cdae31"></a><!-- doxytag: member="LinAlg.h::matMat" ref="ae723dda9ea41c524c370bf9869cdae31" args="(Array2D&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array2D&lt; double &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matMat </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies two 2D matrices. </p>
<p>Multiplies two 2D matrices.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>C. Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00641">641</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00254">g_inverseCholesky()</a>, <a class="el" href="g__inverse_8cpp_source.html#l00364">g_inverseMoorePenrose()</a>, and <a class="el" href="g__inverse_8cpp_source.html#l00198">invertSymmPositiveDefinite()</a>.</p>

</div>
</div>
<a class="anchor" id="abf0946c983ad589902e35ceb9026ef60"></a><!-- doxytag: member="LinAlg.h::mean" ref="abf0946c983ad589902e35ceb9026ef60" args="(const Array&lt; double &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; double &gt; mean </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the mean vector of array "x". </p>
<p>Given a <em>d</em> -dimensional array <em>x</em> with size <em>N1</em> x ... x <em>Nd</em>, this function calculates the mean vector given as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ mean_j = \frac{1}{N1} \sum_{i=1}^{N1} x_{i,j} \]" src="form_61.png"/>
</p>
<p> Example: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left( \begin{array}{*{4}{c}} 1 &amp; 2 &amp; 3 &amp; 4\\ 5 &amp; 6 &amp; 7 &amp; 8\\ 9 &amp; 10 &amp; 11 &amp; 12\\ \end{array} \right) \longrightarrow \frac{1}{3} \left( \begin{array}{*{4}{c}} 1+5+9 &amp; 2+6+10 &amp; 3+7+11 &amp; 4+8+12\\ \end{array} \right) \longrightarrow \left( \begin{array}{*{4}{c}} 5 &amp; 6 &amp; 7 &amp; 8\\ \end{array} \right) \]" src="form_62.png"/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>multidimensional array, from which the mean value will be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the mean vector of <em>x</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>x</em> is only one-dimensional or has no dimensions</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00103">103</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

<p>Referenced by <a class="el" href="_lin_alg_8cpp_source.html#l00602">covariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a371d64240fad4a71cf4536797ede7a09"></a><!-- doxytag: member="LinAlg.h::meanvar" ref="a371d64240fad4a71cf4536797ede7a09" args="(const Array&lt; double &gt; &amp;x, Array&lt; double &gt; &amp;, Array&lt; double &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meanvar </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the mean and variance values of matrix "x". </p>
<p>Given the input matrix <em>x</em>, the mean and variance values are calculated as in the functions <a class="el" href="_lin_alg_8h.html#abf0946c983ad589902e35ceb9026ef60" title="Calculates the mean vector of array &quot;x&quot;.">mean</a> and <a class="el" href="_lin_alg_8h.html#af52620c3e1c24b07a79433a5ff8810a5" title="Calculates the variance vector of array &quot;x&quot;.">variance</a>. The mean and variance values are stored in the vectors <em>m</em> and <em>v</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">m</td><td><a class="el" href="class_vector.html" title="one-dimensional array of double used for vector computations">Vector</a> of mean values. </td></tr>
    <tr><td class="paramname">v</td><td><a class="el" href="class_vector.html" title="one-dimensional array of double used for vector computations">Vector</a> of variances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>x</em> is only one- or non-dimensional</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_lin_alg_8h.html#abf0946c983ad589902e35ceb9026ef60" title="Calculates the mean vector of array &quot;x&quot;.">mean</a>, <a class="el" href="_lin_alg_8h.html#af52620c3e1c24b07a79433a5ff8810a5" title="Calculates the variance vector of array &quot;x&quot;.">variance</a> </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00271">271</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e0b8e509edd20cc23965ecf13c43459"></a><!-- doxytag: member="LinAlg.h::meanvar" ref="a7e0b8e509edd20cc23965ecf13c43459" args="(const Array&lt; double &gt; &amp;pxA, const Array&lt; double &gt; &amp;xA, double &amp;mA, double &amp;vA, const int startA=&#45;1, const int endA=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meanvar </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pxA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>vA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>startA</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>endA</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the mean and variance values of 1d-arrays p(x) </p>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00322">322</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44a6bc0eed7b59bda939e3602f6fb0bc"></a><!-- doxytag: member="LinAlg.h::rankDecomp" ref="a44a6bc0eed7b59bda939e3602f6fb0bc" args="(Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;vmatA, Array2D&lt; double &gt; &amp;hmatA, Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rankDecomp </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the rank of the symmetric matrix "amatA", its eigenvalues and eigenvectors. </p>
<p>Determines the rank of matrix <em>amatA</em> and additionally calculates the eigenvalues and eigenvectors of the matrix. Empty eigenvalues (i.e. eigenvalues equal to zero) are set to the greatest calculated eigenvalue and each eigenvector <img class="formulaInl" alt="$ x_j $" src="form_17.png"/> is scaled by multiplying it with the scalar value <img class="formulaInl" alt="$ \frac{1}{\sqrt{\lambda_j}} $" src="form_106.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which is symmetric, so only the bottom triangular matrix must contain values. At the end of the function <em>amatA</em> always contains the full matrix. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which will contain the scaled eigenvectors. </td></tr>
    <tr><td class="paramname">hmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, that is used to store intermediate results. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector with the calculated eigenvalues in descending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rank of matrix <em>amatA</em>. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>amatA</em> is not a square matrix</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1998</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>2003/10/02 by S. Wiegand due to name change of 'eigensymm';</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="rank_decomp_8cpp_source.html#l00093">93</a> of file <a class="el" href="rank_decomp_8cpp_source.html">rankDecomp.cpp</a>.</p>

<p>References <a class="el" href="eigensymm_8cpp_source.html#l00098">eigensymm_intermediate()</a>, and <a class="el" href="rank_8cpp_source.html#l00088">sym_rank()</a>.</p>

</div>
</div>
<a class="anchor" id="aa79960c3f97b3ea7dd322072e4089119"></a><!-- doxytag: member="LinAlg.h::svd" ref="aa79960c3f97b3ea7dd322072e4089119" args="(const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;umatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;wvecA, unsigned maxIterations=200, bool ignoreThreshold=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svd </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>umatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the singular value decomposition of a rectangular matrix "amatA". </p>
<dl class="user"><dt><b></b></dt><dd>Determines the singular value decomposition of a rectangular matrix "amatA".</dd></dl>
<dl class="user"><dt><b></b></dt><dd>See also: Wikipedia</dd></dl>
<p>Given a <img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> matrix <em>amatA</em>, this routine computes its singular value decomposition, defined as</p>
<p><img class="formulaInl" alt="$ A = UWV^T $" src="form_107.png"/></p>
<p>where W is an <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> diagonal matrix with positive or zero elements, the so-called <em>singular</em> <em>values</em>. The matrices <em>U</em> and <em>V</em> are each orthogonal in the sense that their columns are orthonormal, i.e.</p>
<p><img class="formulaInl" alt="$ UU^T = VV^T = V^TV = 1 $" src="form_108.png"/></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td>The input matrix <em>A</em>, with size <img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> and <img class="formulaInl" alt="$ m \geq n $" src="form_109.png"/>. </td></tr>
    <tr><td class="paramname">umatA</td><td>The <img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> column-orthogonal matrix <em>U</em> determined by the function. </td></tr>
    <tr><td class="paramname">vmatA</td><td>The <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> orthogonal matrix <em>V</em> determined by the function. </td></tr>
    <tr><td class="paramname">w</td><td>n-dimensional vector with the calculated singular values. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>Number of iterations after which the algorithm gives up, if the solution has still not converged. Default is 200 Iterations. </td></tr>
    <tr><td class="paramname">ignoreThreshold</td><td>If set to false, the method throws an exception if the threshold maxIterations is exceeded. Otherwise it uses the approximate intermediate results in the further calculations. The default is true. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">convergence</td><td>exception, if the solution has not converged after maxIterations iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none</dd></dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="svd_8cpp_source.html#l00110">110</a> of file <a class="el" href="svd_8cpp_source.html">svd.cpp</a>.</p>

<p>References <a class="el" href="dlinmin_8cpp_source.html#l00079">SIGN</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00091">g_inverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a68df2fc67b9bf10bb9ef079230fe23d3"></a><!-- doxytag: member="LinAlg.h::svdrank" ref="a68df2fc67b9bf10bb9ef079230fe23d3" args="(const Array2D&lt; double &gt; &amp;amatA, Array2D&lt; double &gt; &amp;umatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;wvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned svdrank </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>umatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the numerical rank of a rectangular matrix "amatA", when a singular value decomposition for "amatA" has taken place before. </p>
<p>For a singular value decomposition defined as</p>
<p><img class="formulaInl" alt="$ A = UWV^T $" src="form_107.png"/></p>
<p>the resulting orthogonal matrices <em>U</em> and <em>V</em> and the singular values in <em>W</em> sorted by descending order are used to determine the rank of input matrix <em>A</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td>The <img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> input matrix <em>A</em>, with <img class="formulaInl" alt="$ m \geq n $" src="form_109.png"/>. </td></tr>
    <tr><td class="paramname">umatA</td><td>The <img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> column-orthogonal matrix <em>U</em>. </td></tr>
    <tr><td class="paramname">vmatA</td><td>The <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> orthogonal matrix <em>V</em>. </td></tr>
    <tr><td class="paramname">wvecA</td><td>n-dimensional vector containing the singular values in descending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none.</dd></dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svd_8cpp.html" title="Used for singular value decomposition of rectangular and square matrices.">svd.cpp</a> </dd></dl>

<p>Definition at line <a class="el" href="svdrank_8cpp_source.html#l00096">96</a> of file <a class="el" href="svdrank_8cpp_source.html">svdrank.cpp</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00091">g_inverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a12f83de2c8c11c875eafc3d4fef3e492"></a><!-- doxytag: member="LinAlg.h::svdsort" ref="a12f83de2c8c11c875eafc3d4fef3e492" args="(Array2D&lt; double &gt; &amp;umatA, Array2D&lt; double &gt; &amp;vmatA, Array&lt; double &gt; &amp;wvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svdsort </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>umatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts the singular values in vector "wvecA" by descending order. </p>
<p>For a singular value decomposition defined as</p>
<p><img class="formulaInl" alt="$ A = UWV^T $" src="form_107.png"/></p>
<p>the resulting orthogonal matrices <em>U</em> and <em>V</em> and the singular values in <em>W</em> can be sorted in a way, that the singular values are given in descending order, when leaving the function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">umatA</td><td>The <img class="formulaInl" alt="$ m \times n $" src="form_58.png"/> matrix <em>U</em>. </td></tr>
    <tr><td class="paramname">vmatA</td><td>The <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>V</em>. </td></tr>
    <tr><td class="paramname">wvecA</td><td>n-dimensional vector containing the singular values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>wvecA</em> is not one-dimensional</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="svd_8cpp.html" title="Used for singular value decomposition of rectangular and square matrices.">svd.cpp</a> </dd></dl>

<p>Definition at line <a class="el" href="svdsort_8cpp_source.html#l00091">91</a> of file <a class="el" href="svdsort_8cpp_source.html">svdsort.cpp</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00091">g_inverse()</a>.</p>

</div>
</div>
<a class="anchor" id="afeb67af8cfdd3d583ad3e6d3dbc4322d"></a><!-- doxytag: member="LinAlg.h::sym_rank" ref="afeb67af8cfdd3d583ad3e6d3dbc4322d" args="(const Array2D&lt; double &gt; &amp;amatA, const Array2D&lt; double &gt; &amp;vmatA, const Array&lt; double &gt; &amp;dvecA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned sym_rank </td>
          <td>(</td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>amatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vmatA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvecA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the rank of the symmetric matrix "amatA". </p>
<p>Determines the rank of the symmetric matrix "amatA".</p>
<p>Given the <img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix <em>amatA</em>, this function uses the eigenvectors <em>vmatA</em> and the eigenvalues <em>dvecA</em> to calculate the rank of <em>amatA</em>. For the calculation of the eigenvectors and eigenvalues see also <a class="el" href="_lin_alg_8h.html#a4740d207478277949f92864c6c36c648" title="Used as frontend for eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmat...">eigensymm(const Array2D&lt;double&gt; &amp;amatA,Array2D&lt;double&gt; &amp;vmatA,Array&lt;double&gt; &amp;dvecA)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">amatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix, which is symmetric and is not changed by the function. </td></tr>
    <tr><td class="paramname">vmatA</td><td><img class="formulaInl" alt="$ n \times n $" src="form_19.png"/> matrix with the normalized eigenvectors, each column contains one eigenvector. The matrix is not changed by the function. </td></tr>
    <tr><td class="paramname">dvecA</td><td>n-dimensional vector of the eigenvalues, given in descending order. The vector is not changed by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rank of matrix <em>amatA</em>. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>dvecA</em> is not one-dimensional or that <em>amatA</em> or <em>vmatA</em> has not the same number of rows or columns than <em>dvecA</em> contains values</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="rank_8cpp_source.html#l00088">88</a> of file <a class="el" href="rank_8cpp_source.html">rank.cpp</a>.</p>

<p>References <a class="el" href="eigenerr_8cpp_source.html#l00094">eigenerr()</a>.</p>

<p>Referenced by <a class="el" href="rank_decomp_8cpp_source.html#l00093">rankDecomp()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6af2de50659417cf1e06d6ccb28a76c"></a><!-- doxytag: member="LinAlg.h::trace" ref="ab6af2de50659417cf1e06d6ccb28a76c" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T trace </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="linalg_simple_test_8cpp-example.html#a5">linalg_simple_test.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_lin_alg_8h_source.html#l00458">458</a> of file <a class="el" href="_lin_alg_8h_source.html">LinAlg.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa164073a51840262b1be68a17f91a73"></a><!-- doxytag: member="LinAlg.h::transpose" ref="aaa164073a51840262b1be68a17f91a73" args="(const Array&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; T &gt; transpose </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="linalg_simple_test_8cpp-example.html#a3">linalg_simple_test.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_lin_alg_8h_source.html#l00341">341</a> of file <a class="el" href="_lin_alg_8h_source.html">LinAlg.h</a>.</p>

<p>Referenced by <a class="el" href="g__inverse_8cpp_source.html#l00254">g_inverseCholesky()</a>, <a class="el" href="g__inverse_8cpp_source.html#l00364">g_inverseMoorePenrose()</a>, and <a class="el" href="_lin_alg_8cpp_source.html#l00824">invertSymm()</a>.</p>

</div>
</div>
<a class="anchor" id="af52620c3e1c24b07a79433a5ff8810a5"></a><!-- doxytag: member="LinAlg.h::variance" ref="af52620c3e1c24b07a79433a5ff8810a5" args="(const Array&lt; double &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; double &gt; variance </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the variance vector of array "x". </p>
<p>Given a <em>d</em> -dimensional array <em>x</em> with size <em>N1</em> x ... x <em>Nd</em> and mean value vector <em>m</em>, this function calculates the variance vector given as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ variance = \frac{1}{N1} \sum_{i=1}^{N1} (x_i - m_i)^2 \]" src="form_63.png"/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>multidimensional array, from which the variance will be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the variance vector of <em>x</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">SharkException</td><td>the type of the exception will be "size mismatch" and indicates that <em>x</em> is only one-dimensional or has no dimensions or has no values in its first dimension</td></tr>
  </table>
  </dd>
</dl>
<p>Please follow the link to view the source code of the example. The example can be executed in the example directory of package LinAlg.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>M. Kreutz </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>1995</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none</dd></dl>
<dl class="user"><dt><b>Status</b></dt><dd>stable </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00151">151</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dda376d959f56a8673f34147049b84a"></a><!-- doxytag: member="LinAlg.h::vecMatVec" ref="a5dda376d959f56a8673f34147049b84a" args="(const Array&lt; double &gt; &amp;A, unsigned int i, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C, unsigned int j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vecMatVec </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the scalar <img class="formulaInl" alt="$ A_i B C_j $" src="form_113.png"/>. </p>
<p>Returns the scalar <img class="formulaInl" alt="$ A_i B C_j $" src="form_113.png"/>.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>C. Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00789">789</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18749fe8031357354c728203d7a50e28"></a><!-- doxytag: member="LinAlg.h::vecMatVec" ref="a18749fe8031357354c728203d7a50e28" args="(const Array&lt; double &gt; &amp;A, const Array2D&lt; double &gt; &amp;B, const Array&lt; double &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vecMatVec </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array2D&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the scalar ABC. </p>
<p>Returns the scalar ABC.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>C. Igel </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007</dd></dl>
<dl class="user"><dt><b>Changes</b></dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="_lin_alg_8cpp_source.html#l00755">755</a> of file <a class="el" href="_lin_alg_8cpp_source.html">LinAlg.cpp</a>.</p>

</div>
</div>
</div>
</div>
</div>
</body></html>
